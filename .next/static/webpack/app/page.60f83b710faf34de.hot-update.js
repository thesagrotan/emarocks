"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/blob-simulation/blob.ts":
/*!********************************************!*\
  !*** ./components/blob-simulation/blob.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./particle */ \"(app-pages-browser)/./components/blob-simulation/particle.ts\");\n/* harmony import */ var _spring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spring */ \"(app-pages-browser)/./components/blob-simulation/spring.ts\");\n\n\n\n// Temporary vector for calculations\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n// Blob Class - represents a complete blob with particles and springs\nclass Blob {\n    setup() {\n        this.particles.length = 0;\n        this.springs.length = 0;\n        const safeRadius = this.maxRadius; // Already ensured > 0 in constructor\n        const angleStep = Math.PI * 2 / this.edgePointCount;\n        // Ensure initialSpringLength is positive and reasonable\n        const initialSpringLength = Math.max(1e-6, safeRadius * Math.sin(Math.PI / this.edgePointCount) * 2);\n        for(let i = 0; i < this.edgePointCount; i++){\n            const angle = i * angleStep;\n            const x = Math.cos(angle) * safeRadius + this.centre.x;\n            const y = Math.sin(angle) * safeRadius + this.centre.y;\n            this.particles.push(new _particle__WEBPACK_IMPORTED_MODULE_0__.Particle(x, y));\n            if (i > 0) {\n                this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[i], this.particles[i - 1], initialSpringLength));\n            }\n        }\n        this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[0], this.particles[this.edgePointCount - 1], initialSpringLength));\n    }\n    updateCentre() {\n        if (this.particles.length === 0) return;\n        this.centre.set(0, 0);\n        this.particles.forEach((p)=>this.centre.add(p.pos));\n        this.centre.divideScalar(this.particles.length);\n    }\n    updateMaxRadius() {\n        if (this.particles.length === 0) {\n            this.maxRadius = 0;\n            return;\n        }\n        let maxDistSq = 0;\n        this.particles.forEach((particle)=>{\n            const distSq = this.centre.distanceToSquared(particle.pos);\n            if (distSq > maxDistSq) maxDistSq = distSq;\n        });\n        this.maxRadius = Math.sqrt(maxDistSq);\n    }\n    // Repel other blobs\n    repelBlobs(blobs, interactionStrength) {\n        blobs.forEach((blobB)=>{\n            if (this.id === blobB.id) return;\n            // Use the same repelDistance for both blobs to ensure consistency\n            const effectiveRepelDistance = Math.max(this.repelDistance, blobB.repelDistance);\n            const distBetweenCentersSq = this.centre.distanceToSquared(blobB.centre);\n            // Use radii squared for comparison to avoid sqrt\n            const combinedRadii = this.maxRadius + blobB.maxRadius;\n            const interactionRangeSq = Math.pow(combinedRadii + effectiveRepelDistance, 2);\n            // Optimization: Broad phase check based on centers and radii + repel distance\n            if (distBetweenCentersSq > interactionRangeSq) return;\n            // Narrow phase: Check particle pairs\n            this.particles.forEach((particleA)=>{\n                blobB.particles.forEach((particleB)=>{\n                    tempVec.copy(particleA.pos).sub(particleB.pos);\n                    const distSq = tempVec.lengthSq(); // Use squared distance\n                    // Apply repulsion force if within repelDistance squared\n                    const repelDistSq = effectiveRepelDistance * effectiveRepelDistance;\n                    if (distSq > 1e-12 && distSq < repelDistSq) {\n                        const dist = Math.sqrt(distSq);\n                        const overlap = effectiveRepelDistance - dist;\n                        // Calculate force magnitude based on overlap and strength\n                        let forceMagnitude = overlap * interactionStrength;\n                        // Cap the force magnitude\n                        forceMagnitude = Math.min(forceMagnitude, this.maxRepulsionForce);\n                        // Normalize direction vector (reuse tempVec) and apply magnitude\n                        tempVec.multiplyScalar(forceMagnitude / dist);\n                        // Apply forces ensuring they are finite\n                        particleA.applyForce(tempVec);\n                        particleB.applyForce(tempVec.multiplyScalar(-1)); // Apply opposite force\n                    }\n                });\n            });\n        });\n    }\n    get area() {\n        let total = 0;\n        if (this.particles.length < 3) return 0;\n        for(let i = 0; i < this.edgePointCount; i++){\n            const p1 = this.particles[i].pos;\n            const p2 = this.particles[(i + 1) % this.edgePointCount].pos;\n            total += p1.x * p2.y - p2.x * p1.y;\n        }\n        return Math.abs(total / 2);\n    }\n    grow(maxExpansionFactor) {\n        if (this.initialArea <= 0) return;\n        const maxTargetArea = this.initialArea * Math.max(1, maxExpansionFactor);\n        if (this.targetArea < maxTargetArea) {\n            this.targetArea *= 1.005; // Slow growth\n            this.targetArea = Math.min(this.targetArea, maxTargetArea); // Clamp to max\n        } else if (this.targetArea > maxTargetArea) {\n            this.targetArea = maxTargetArea;\n        }\n    }\n    maintainPressure() {\n        const currentArea = this.area;\n        if (currentArea < 1e-6 || this.targetArea < 1e-6) return;\n        // Make pressure force proportional to the difference ratio, but prevent extreme forces\n        const areaRatio = this.targetArea / currentArea;\n        // Clamp the ratio to prevent excessive forces when area is very small\n        const clampedRatio = Math.max(0.5, Math.min(areaRatio, 2.0));\n        const pressureDifference = clampedRatio - 1;\n        const forceSize = pressureDifference * this.pressureConstant;\n        // Limit the maximum force size to prevent instability\n        const maxPressureForce = 0.1; // Example cap\n        const cappedForceSize = Math.max(-maxPressureForce, Math.min(forceSize, maxPressureForce));\n        this.particles.forEach((particle, i)=>{\n            const prev = this.particles[(i + this.edgePointCount - 1) % this.edgePointCount];\n            const next = this.particles[(i + 1) % this.edgePointCount];\n            // Calculate edge vectors from the particle to its neighbors\n            const toPrev = tempVec.copy(prev.pos).sub(particle.pos);\n            const toNext = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2().copy(next.pos).sub(particle.pos); // Use a separate Vector2 instance\n            // Calculate outward normal using the cross product concept (for 2D)\n            const edgeVector = toNext.sub(toPrev); // Vector along the edge (next - prev)\n            const outwardNormal = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(-edgeVector.y, edgeVector.x); // Perpendicular vector\n            if (outwardNormal.lengthSq() < 1e-12) return; // Skip if normal is zero length\n            outwardNormal.normalize();\n            outwardNormal.multiplyScalar(cappedForceSize);\n            particle.applyForce(outwardNormal);\n        });\n    }\n    // Collision with Static Obstacles\n    collideWithStaticShape(ctx, shapeType, shapeParams) {\n        if (!shapeType || !shapeParams) return;\n        let shapeBounds = null;\n        if (shapeType === 'rectangle') {\n            shapeBounds = {\n                minX: shapeParams.x,\n                minY: shapeParams.y,\n                maxX: shapeParams.x + shapeParams.size,\n                maxY: shapeParams.y + shapeParams.size\n            };\n        } else if (shapeType === 'letter' && shapeParams.letter && ctx) {\n            const letterWidth = shapeParams.size * 0.8;\n            const letterHeight = shapeParams.size;\n            const letterCenterX = shapeParams.x + shapeParams.size / 2;\n            const letterCenterY = shapeParams.y + shapeParams.size / 2;\n            shapeBounds = {\n                minX: letterCenterX - letterWidth / 2,\n                minY: letterCenterY - letterHeight / 2,\n                maxX: letterCenterX + letterWidth / 2,\n                maxY: letterCenterY + letterHeight / 2\n            };\n        }\n        if (!shapeBounds) return;\n        this.particles.forEach((particle)=>{\n            if (particle.pos.x > shapeBounds.minX && particle.pos.x < shapeBounds.maxX && particle.pos.y > shapeBounds.minY && particle.pos.y < shapeBounds.maxY) {\n                const dxMin = particle.pos.x - shapeBounds.minX;\n                const dxMax = shapeBounds.maxX - particle.pos.x;\n                const dyMin = particle.pos.y - shapeBounds.minY;\n                const dyMax = shapeBounds.maxY - particle.pos.y;\n                const minDist = Math.min(dxMin, dxMax, dyMin, dyMax);\n                const pushForce = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();\n                let overlap = 0;\n                if (minDist === dxMin) {\n                    pushForce.set(-1, 0);\n                    overlap = dxMin;\n                } else if (minDist === dxMax) {\n                    pushForce.set(1, 0);\n                    overlap = dxMax;\n                } else if (minDist === dyMin) {\n                    pushForce.set(0, -1);\n                    overlap = dyMin;\n                } else {\n                    pushForce.set(0, 1);\n                    overlap = dyMax;\n                }\n                // Apply a smaller, continuous force\n                pushForce.multiplyScalar(0.2); // Smaller push strength\n                particle.applyForce(pushForce);\n                // Apply damping on collision\n                particle.vel.multiplyScalar(0.5); // Stronger damping on static collision\n            }\n        });\n    }\n    draw(ctx, fillColor, strokeColor) {\n        var _this_particles_;\n        if (this.particles.length < 2) return;\n        ctx.beginPath();\n        // Ensure first particle exists before moving to it\n        if (!((_this_particles_ = this.particles[0]) === null || _this_particles_ === void 0 ? void 0 : _this_particles_.pos)) {\n            console.warn(\"First particle missing in draw\");\n            return;\n        }\n        ctx.moveTo(this.particles[0].pos.x, this.particles[0].pos.y);\n        for(let i = 1; i <= this.edgePointCount; i++){\n            var _this_particles_currentIndex;\n            const currentIndex = i % this.edgePointCount;\n            if ((_this_particles_currentIndex = this.particles[currentIndex]) === null || _this_particles_currentIndex === void 0 ? void 0 : _this_particles_currentIndex.pos) {\n                ctx.lineTo(this.particles[currentIndex].pos.x, this.particles[currentIndex].pos.y);\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(currentIndex, \" during draw\"));\n                ctx.closePath();\n                break;\n            }\n        }\n        ctx.closePath(); // Close path after loop\n        // Check context state before filling/stroking\n        if (ctx.fillStyle !== fillColor) ctx.fillStyle = fillColor;\n        if (ctx.strokeStyle !== strokeColor) ctx.strokeStyle = strokeColor;\n        ctx.lineWidth = 1;\n        ctx.fill();\n        ctx.stroke();\n    }\n    // Get SVG path data for this blob\n    getSVGPath() {\n        if (this.particles.length < 2) return \"\";\n        let path = \"M \".concat(this.particles[0].pos.x.toFixed(2), \" \").concat(this.particles[0].pos.y.toFixed(2));\n        for(let i = 1; i <= this.edgePointCount; i++){\n            const particle = this.particles[i % this.edgePointCount];\n            if (particle === null || particle === void 0 ? void 0 : particle.pos) {\n                path += \" L \".concat(particle.pos.x.toFixed(2), \" \").concat(particle.pos.y.toFixed(2));\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(i % this.edgePointCount, \" during SVG path generation\"));\n                return path + \" Z\";\n            }\n        }\n        path += \" Z\";\n        return path;\n    }\n    update(blobs, springTension, canvasWidth, canvasHeight, margin, isRoundedContainer, interactionStrength, maxExpansionFactor, gravity, damping, staticShapeType, staticShapeParams, ctx) {\n        // --- Force Application Phase ---\n        // Apply internal forces first (pressure, springs)\n        this.maintainPressure();\n        this.springs.forEach((spring)=>spring.update(springTension));\n        // Apply external forces (gravity, inter-blob repulsion, static collision)\n        this.particles.forEach((particle)=>{\n            particle.applyForce(new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, gravity * 0.1)); // Apply gravity per particle\n        });\n        this.repelBlobs(blobs, interactionStrength);\n        if (ctx && staticShapeType && staticShapeParams) {\n            this.collideWithStaticShape(ctx, staticShapeType, staticShapeParams);\n        }\n        // --- Update Phase ---\n        // Update particles using applied forces and damping\n        this.particles.forEach((particle)=>{\n            particle.update(canvasWidth, canvasHeight, margin, isRoundedContainer, damping);\n        });\n        // Update blob state based on new particle positions\n        this.updateCentre();\n        this.updateMaxRadius();\n        // Apply growth after updates\n        this.grow(maxExpansionFactor);\n    }\n    constructor(x, y, edgePointCount, startSize, repelDistance){\n        this.pressureConstant = 0.08 // Pressure constant\n        ;\n        this.maxRepulsionForce = 0.5 // Cap for repulsion force magnitude\n        ;\n        this.id = Math.random();\n        this.centre = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(x, y);\n        this.edgePointCount = edgePointCount;\n        this.particles = [];\n        this.springs = [];\n        this.maxRadius = Math.max(1, startSize); // Ensure startSize is at least 1\n        this.initialArea = Math.PI * this.maxRadius * this.maxRadius;\n        this.targetArea = this.initialArea;\n        this.repelDistance = repelDistance;\n        this.setup();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYmxvYi1zaW11bGF0aW9uL2Jsb2IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnQztBQUNNO0FBQ0o7QUFFbEMsb0NBQW9DO0FBQ3BDLE1BQU1HLFVBQVUsSUFBSUgsMENBQU9BO0FBRTNCLHFFQUFxRTtBQUM5RCxNQUFNSTtJQTBCWEMsUUFBUTtRQUNOLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxPQUFPLENBQUNELE1BQU0sR0FBRztRQUV0QixNQUFNRSxhQUFhLElBQUksQ0FBQ0MsU0FBUyxFQUFFLHFDQUFxQztRQUN4RSxNQUFNQyxZQUFZLEtBQU1FLEVBQUUsR0FBRyxJQUFLLElBQUksQ0FBQ0MsY0FBYztRQUNyRCx3REFBd0Q7UUFDeEQsTUFBTUMsc0JBQXNCSCxLQUFLSSxHQUFHLENBQUMsTUFBTVAsYUFBYUcsS0FBS0ssR0FBRyxDQUFDTCxLQUFLQyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxjQUFjLElBQUk7UUFFbEcsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixjQUFjLEVBQUVJLElBQUs7WUFDNUMsTUFBTUMsUUFBUUQsSUFBSVA7WUFDbEIsTUFBTVMsSUFBSVIsS0FBS1MsR0FBRyxDQUFDRixTQUFTVixhQUFhLElBQUksQ0FBQ2EsTUFBTSxDQUFDRixDQUFDO1lBQ3RELE1BQU1HLElBQUlYLEtBQUtLLEdBQUcsQ0FBQ0UsU0FBU1YsYUFBYSxJQUFJLENBQUNhLE1BQU0sQ0FBQ0MsQ0FBQztZQUN0RCxJQUFJLENBQUNqQixTQUFTLENBQUNrQixJQUFJLENBQUMsSUFBSXZCLCtDQUFRQSxDQUFDbUIsR0FBR0c7WUFFcEMsSUFBSUwsSUFBSSxHQUFHO2dCQUNULElBQUksQ0FBQ1YsT0FBTyxDQUFDZ0IsSUFBSSxDQUFDLElBQUl0QiwyQ0FBTUEsQ0FBQyxJQUFJLENBQUNJLFNBQVMsQ0FBQ1ksRUFBRSxFQUFFLElBQUksQ0FB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O1FBR3RCLElBQUksQ0FBQ3ZILE1BQU0sR0FBRyxJQUFJdEIsMENBQU9BLENBQUNvQixHQUFHRztRQUM3QixJQUFJLENBQUNULGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDUixTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNFLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0UsU0FBUyxHQUFHRSxLQUFLSSxHQUFHLENBQUMsR0FBRzRILFlBQVksaUNBQWlDO1FBQzFFLElBQUksQ0FBQ3ZFLFdBQVcsR0FBR3pELEtBQUtDLEVBQUUsR0FBRyxJQUFJLENBQUNILFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVM7UUFDNUQsSUFBSSxDQUFDNkQsVUFBVSxHQUFHLElBQUksQ0FBQ0YsV0FBVztRQUNsQyxJQUFJLENBQUN6QixhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ3ZDLEtBQUs7SUFDWjtBQW1URiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhbmllbC9EZXZlbG9wZXIvZW1hcm9ja3MvY29tcG9uZW50cy9ibG9iLXNpbXVsYXRpb24vYmxvYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZSB9IGZyb20gXCIuL3BhcnRpY2xlXCI7XG5pbXBvcnQgeyBTcHJpbmcgfSBmcm9tIFwiLi9zcHJpbmdcIjtcblxuLy8gVGVtcG9yYXJ5IHZlY3RvciBmb3IgY2FsY3VsYXRpb25zXG5jb25zdCB0ZW1wVmVjID0gbmV3IFZlY3RvcjIoKTtcblxuLy8gQmxvYiBDbGFzcyAtIHJlcHJlc2VudHMgYSBjb21wbGV0ZSBibG9iIHdpdGggcGFydGljbGVzIGFuZCBzcHJpbmdzXG5leHBvcnQgY2xhc3MgQmxvYiB7XG4gIGNlbnRyZTogVmVjdG9yMjtcbiAgbWF4UmFkaXVzOiBudW1iZXI7IC8vIER5bmFtaWMgcmFkaXVzIGJhc2VkIG9uIHBhcnRpY2xlIHBvc2l0aW9uc1xuICBlZGdlUG9pbnRDb3VudDogbnVtYmVyO1xuICBwYXJ0aWNsZXM6IFBhcnRpY2xlW107XG4gIHNwcmluZ3M6IFNwcmluZ1tdO1xuXG4gIGluaXRpYWxBcmVhOiBudW1iZXI7XG4gIHRhcmdldEFyZWE6IG51bWJlcjtcbiAgcmVwZWxEaXN0YW5jZTogbnVtYmVyO1xuICBwcmVzc3VyZUNvbnN0YW50OiBudW1iZXIgPSAwLjA4OyAvLyBQcmVzc3VyZSBjb25zdGFudFxuICBtYXhSZXB1bHNpb25Gb3JjZTogbnVtYmVyID0gMC41OyAvLyBDYXAgZm9yIHJlcHVsc2lvbiBmb3JjZSBtYWduaXR1ZGVcbiAgaWQ6IG51bWJlciA9IE1hdGgucmFuZG9tKCk7XG5cbiAgY29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVkZ2VQb2ludENvdW50OiBudW1iZXIsIHN0YXJ0U2l6ZTogbnVtYmVyLCByZXBlbERpc3RhbmNlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNlbnRyZSA9IG5ldyBWZWN0b3IyKHgsIHkpO1xuICAgIHRoaXMuZWRnZVBvaW50Q291bnQgPSBlZGdlUG9pbnRDb3VudDtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuICAgIHRoaXMuc3ByaW5ncyA9IFtdO1xuICAgIHRoaXMubWF4UmFkaXVzID0gTWF0aC5tYXgoMSwgc3RhcnRTaXplKTsgLy8gRW5zdXJlIHN0YXJ0U2l6ZSBpcyBhdCBsZWFzdCAxXG4gICAgdGhpcy5pbml0aWFsQXJlYSA9IE1hdGguUEkgKiB0aGlzLm1heFJhZGl1cyAqIHRoaXMubWF4UmFkaXVzO1xuICAgIHRoaXMudGFyZ2V0QXJlYSA9IHRoaXMuaW5pdGlhbEFyZWE7XG4gICAgdGhpcy5yZXBlbERpc3RhbmNlID0gcmVwZWxEaXN0YW5jZTtcbiAgICB0aGlzLnNldHVwKCk7XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnBhcnRpY2xlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc3ByaW5ncy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3Qgc2FmZVJhZGl1cyA9IHRoaXMubWF4UmFkaXVzOyAvLyBBbHJlYWR5IGVuc3VyZWQgPiAwIGluIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgYW5nbGVTdGVwID0gKE1hdGguUEkgKiAyKSAvIHRoaXMuZWRnZVBvaW50Q291bnQ7XG4gICAgLy8gRW5zdXJlIGluaXRpYWxTcHJpbmdMZW5ndGggaXMgcG9zaXRpdmUgYW5kIHJlYXNvbmFibGVcbiAgICBjb25zdCBpbml0aWFsU3ByaW5nTGVuZ3RoID0gTWF0aC5tYXgoMWUtNiwgc2FmZVJhZGl1cyAqIE1hdGguc2luKE1hdGguUEkgLyB0aGlzLmVkZ2VQb2ludENvdW50KSAqIDIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFuZ2xlID0gaSAqIGFuZ2xlU3RlcDtcbiAgICAgIGNvbnN0IHggPSBNYXRoLmNvcyhhbmdsZSkgKiBzYWZlUmFkaXVzICsgdGhpcy5jZW50cmUueDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLnNpbihhbmdsZSkgKiBzYWZlUmFkaXVzICsgdGhpcy5jZW50cmUueTtcbiAgICAgIHRoaXMucGFydGljbGVzLnB1c2gobmV3IFBhcnRpY2xlKHgsIHkpKTtcblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuc3ByaW5ncy5wdXNoKG5ldyBTcHJpbmcodGhpcy5wYXJ0aWNsZXNbaV0sIHRoaXMucGFydGljbGVzW2kgLSAxXSwgaW5pdGlhbFNwcmluZ0xlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNwcmluZ3MucHVzaChuZXcgU3ByaW5nKHRoaXMucGFydGljbGVzWzBdLCB0aGlzLnBhcnRpY2xlc1t0aGlzLmVkZ2VQb2ludENvdW50IC0gMV0sIGluaXRpYWxTcHJpbmdMZW5ndGgpKTtcbiAgfVxuXG4gIHVwZGF0ZUNlbnRyZSgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdGhpcy5jZW50cmUuc2V0KDAsIDApO1xuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2gocCA9PiB0aGlzLmNlbnRyZS5hZGQocC5wb3MpKTtcbiAgICB0aGlzLmNlbnRyZS5kaXZpZGVTY2FsYXIodGhpcy5wYXJ0aWNsZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHVwZGF0ZU1heFJhZGl1cygpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXhEaXN0U3EgPSAwO1xuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlKSA9PiB7XG4gICAgICBjb25zdCBkaXN0U3EgPSB0aGlzLmNlbnRyZS5kaXN0YW5jZVRvU3F1YXJlZChwYXJ0aWNsZS5wb3MpO1xuICAgICAgaWYgKGRpc3RTcSA+IG1heERpc3RTcSkgbWF4RGlzdFNxID0gZGlzdFNxO1xuICAgIH0pO1xuICAgIHRoaXMubWF4UmFkaXVzID0gTWF0aC5zcXJ0KG1heERpc3RTcSk7XG4gIH1cblxuICAvLyBSZXBlbCBvdGhlciBibG9ic1xuICByZXBlbEJsb2JzKGJsb2JzOiBCbG9iW10sIGludGVyYWN0aW9uU3RyZW5ndGg6IG51bWJlcikge1xuICAgIGJsb2JzLmZvckVhY2goKGJsb2JCKSA9PiB7XG4gICAgICBpZiAodGhpcy5pZCA9PT0gYmxvYkIuaWQpIHJldHVybjtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIHJlcGVsRGlzdGFuY2UgZm9yIGJvdGggYmxvYnMgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gICAgICBjb25zdCBlZmZlY3RpdmVSZXBlbERpc3RhbmNlID0gTWF0aC5tYXgodGhpcy5yZXBlbERpc3RhbmNlLCBibG9iQi5yZXBlbERpc3RhbmNlKTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdEJldHdlZW5DZW50ZXJzU3EgPSB0aGlzLmNlbnRyZS5kaXN0YW5jZVRvU3F1YXJlZChibG9iQi5jZW50cmUpO1xuICAgICAgLy8gVXNlIHJhZGlpIHNxdWFyZWQgZm9yIGNvbXBhcmlzb24gdG8gYXZvaWQgc3FydFxuICAgICAgY29uc3QgY29tYmluZWRSYWRpaSA9IHRoaXMubWF4UmFkaXVzICsgYmxvYkIubWF4UmFkaXVzO1xuICAgICAgY29uc3QgaW50ZXJhY3Rpb25SYW5nZVNxID0gTWF0aC5wb3coY29tYmluZWRSYWRpaSArIGVmZmVjdGl2ZVJlcGVsRGlzdGFuY2UsIDIpO1xuXG4gICAgICAvLyBPcHRpbWl6YXRpb246IEJyb2FkIHBoYXNlIGNoZWNrIGJhc2VkIG9uIGNlbnRlcnMgYW5kIHJhZGlpICsgcmVwZWwgZGlzdGFuY2VcbiAgICAgIGlmIChkaXN0QmV0d2VlbkNlbnRlcnNTcSA+IGludGVyYWN0aW9uUmFuZ2VTcSkgcmV0dXJuO1xuXG4gICAgICAvLyBOYXJyb3cgcGhhc2U6IENoZWNrIHBhcnRpY2xlIHBhaXJzXG4gICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZUEpID0+IHtcbiAgICAgICAgYmxvYkIucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlQikgPT4ge1xuICAgICAgICAgIHRlbXBWZWMuY29weShwYXJ0aWNsZUEucG9zKS5zdWIocGFydGljbGVCLnBvcyk7XG4gICAgICAgICAgY29uc3QgZGlzdFNxID0gdGVtcFZlYy5sZW5ndGhTcSgpOyAvLyBVc2Ugc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAgICAgLy8gQXBwbHkgcmVwdWxzaW9uIGZvcmNlIGlmIHdpdGhpbiByZXBlbERpc3RhbmNlIHNxdWFyZWRcbiAgICAgICAgICBjb25zdCByZXBlbERpc3RTcSA9IGVmZmVjdGl2ZVJlcGVsRGlzdGFuY2UgKiBlZmZlY3RpdmVSZXBlbERpc3RhbmNlO1xuICAgICAgICAgIGlmIChkaXN0U3EgPiAxZS0xMiAmJiBkaXN0U3EgPCByZXBlbERpc3RTcSkgeyAvLyBDb21wYXJlIHNxdWFyZWQgZGlzdGFuY2VzXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RTcSk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGFwID0gZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSAtIGRpc3Q7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBmb3JjZSBtYWduaXR1ZGUgYmFzZWQgb24gb3ZlcmxhcCBhbmQgc3RyZW5ndGhcbiAgICAgICAgICAgIGxldCBmb3JjZU1hZ25pdHVkZSA9IG92ZXJsYXAgKiBpbnRlcmFjdGlvblN0cmVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBDYXAgdGhlIGZvcmNlIG1hZ25pdHVkZVxuICAgICAgICAgICAgZm9yY2VNYWduaXR1ZGUgPSBNYXRoLm1pbihmb3JjZU1hZ25pdHVkZSwgdGhpcy5tYXhSZXB1bHNpb25Gb3JjZSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb24gdmVjdG9yIChyZXVzZSB0ZW1wVmVjKSBhbmQgYXBwbHkgbWFnbml0dWRlXG4gICAgICAgICAgICB0ZW1wVmVjLm11bHRpcGx5U2NhbGFyKGZvcmNlTWFnbml0dWRlIC8gZGlzdCk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGZvcmNlcyBlbnN1cmluZyB0aGV5IGFyZSBmaW5pdGVcbiAgICAgICAgICAgIHBhcnRpY2xlQS5hcHBseUZvcmNlKHRlbXBWZWMpO1xuICAgICAgICAgICAgcGFydGljbGVCLmFwcGx5Rm9yY2UodGVtcFZlYy5tdWx0aXBseVNjYWxhcigtMSkpOyAvLyBBcHBseSBvcHBvc2l0ZSBmb3JjZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBhcmVhKCk6IG51bWJlciB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoIDwgMykgcmV0dXJuIDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRnZVBvaW50Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcDEgPSB0aGlzLnBhcnRpY2xlc1tpXS5wb3M7XG4gICAgICBjb25zdCBwMiA9IHRoaXMucGFydGljbGVzWyhpICsgMSkgJSB0aGlzLmVkZ2VQb2ludENvdW50XS5wb3M7XG4gICAgICB0b3RhbCArPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnModG90YWwgLyAyKTtcbiAgfVxuXG4gIGdyb3cobWF4RXhwYW5zaW9uRmFjdG9yOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsQXJlYSA8PSAwKSByZXR1cm47XG4gICAgY29uc3QgbWF4VGFyZ2V0QXJlYSA9IHRoaXMuaW5pdGlhbEFyZWEgKiBNYXRoLm1heCgxLCBtYXhFeHBhbnNpb25GYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMudGFyZ2V0QXJlYSA8IG1heFRhcmdldEFyZWEpIHtcbiAgICAgIHRoaXMudGFyZ2V0QXJlYSAqPSAxLjAwNTsgLy8gU2xvdyBncm93dGhcbiAgICAgIHRoaXMudGFyZ2V0QXJlYSA9IE1hdGgubWluKHRoaXMudGFyZ2V0QXJlYSwgbWF4VGFyZ2V0QXJlYSk7IC8vIENsYW1wIHRvIG1heFxuICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXRBcmVhID4gbWF4VGFyZ2V0QXJlYSkge1xuICAgICAgdGhpcy50YXJnZXRBcmVhID0gbWF4VGFyZ2V0QXJlYTtcbiAgICB9XG4gIH1cblxuICBtYWludGFpblByZXNzdXJlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRBcmVhID0gdGhpcy5hcmVhO1xuICAgIGlmIChjdXJyZW50QXJlYSA8IDFlLTYgfHwgdGhpcy50YXJnZXRBcmVhIDwgMWUtNikgcmV0dXJuO1xuXG4gICAgLy8gTWFrZSBwcmVzc3VyZSBmb3JjZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRpZmZlcmVuY2UgcmF0aW8sIGJ1dCBwcmV2ZW50IGV4dHJlbWUgZm9yY2VzXG4gICAgY29uc3QgYXJlYVJhdGlvID0gdGhpcy50YXJnZXRBcmVhIC8gY3VycmVudEFyZWE7XG4gICAgLy8gQ2xhbXAgdGhlIHJhdGlvIHRvIHByZXZlbnQgZXhjZXNzaXZlIGZvcmNlcyB3aGVuIGFyZWEgaXMgdmVyeSBzbWFsbFxuICAgIGNvbnN0IGNsYW1wZWRSYXRpbyA9IE1hdGgubWF4KDAuNSwgTWF0aC5taW4oYXJlYVJhdGlvLCAyLjApKTtcbiAgICBjb25zdCBwcmVzc3VyZURpZmZlcmVuY2UgPSBjbGFtcGVkUmF0aW8gLSAxO1xuXG4gICAgY29uc3QgZm9yY2VTaXplID0gcHJlc3N1cmVEaWZmZXJlbmNlICogdGhpcy5wcmVzc3VyZUNvbnN0YW50O1xuXG4gICAgLy8gTGltaXQgdGhlIG1heGltdW0gZm9yY2Ugc2l6ZSB0byBwcmV2ZW50IGluc3RhYmlsaXR5XG4gICAgY29uc3QgbWF4UHJlc3N1cmVGb3JjZSA9IDAuMTsgLy8gRXhhbXBsZSBjYXBcbiAgICBjb25zdCBjYXBwZWRGb3JjZVNpemUgPSBNYXRoLm1heCgtbWF4UHJlc3N1cmVGb3JjZSwgTWF0aC5taW4oZm9yY2VTaXplLCBtYXhQcmVzc3VyZUZvcmNlKSk7XG5cbiAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMucGFydGljbGVzWyhpICsgdGhpcy5lZGdlUG9pbnRDb3VudCAtIDEpICUgdGhpcy5lZGdlUG9pbnRDb3VudF07XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5wYXJ0aWNsZXNbKGkgKyAxKSAlIHRoaXMuZWRnZVBvaW50Q291bnRdO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgZWRnZSB2ZWN0b3JzIGZyb20gdGhlIHBhcnRpY2xlIHRvIGl0cyBuZWlnaGJvcnNcbiAgICAgIGNvbnN0IHRvUHJldiA9IHRlbXBWZWMuY29weShwcmV2LnBvcykuc3ViKHBhcnRpY2xlLnBvcyk7XG4gICAgICBjb25zdCB0b05leHQgPSBuZXcgVmVjdG9yMigpLmNvcHkobmV4dC5wb3MpLnN1YihwYXJ0aWNsZS5wb3MpOyAvLyBVc2UgYSBzZXBhcmF0ZSBWZWN0b3IyIGluc3RhbmNlXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvdXR3YXJkIG5vcm1hbCB1c2luZyB0aGUgY3Jvc3MgcHJvZHVjdCBjb25jZXB0IChmb3IgMkQpXG4gICAgICBjb25zdCBlZGdlVmVjdG9yID0gdG9OZXh0LnN1Yih0b1ByZXYpOyAvLyBWZWN0b3IgYWxvbmcgdGhlIGVkZ2UgKG5leHQgLSBwcmV2KVxuICAgICAgY29uc3Qgb3V0d2FyZE5vcm1hbCA9IG5ldyBWZWN0b3IyKC1lZGdlVmVjdG9yLnksIGVkZ2VWZWN0b3IueCk7IC8vIFBlcnBlbmRpY3VsYXIgdmVjdG9yXG5cbiAgICAgIGlmIChvdXR3YXJkTm9ybWFsLmxlbmd0aFNxKCkgPCAxZS0xMikgcmV0dXJuOyAvLyBTa2lwIGlmIG5vcm1hbCBpcyB6ZXJvIGxlbmd0aFxuXG4gICAgICBvdXR3YXJkTm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgb3V0d2FyZE5vcm1hbC5tdWx0aXBseVNjYWxhcihjYXBwZWRGb3JjZVNpemUpO1xuICAgICAgcGFydGljbGUuYXBwbHlGb3JjZShvdXR3YXJkTm9ybWFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENvbGxpc2lvbiB3aXRoIFN0YXRpYyBPYnN0YWNsZXNcbiAgY29sbGlkZVdpdGhTdGF0aWNTaGFwZShcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgICBzaGFwZVR5cGU6ICdyZWN0YW5nbGUnIHwgJ2xldHRlcicgfCBudWxsLFxuICAgIHNoYXBlUGFyYW1zOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBzaXplOiBudW1iZXI7IGxldHRlcj86IHN0cmluZyB9IHwgbnVsbFxuICApIHtcbiAgICBpZiAoIXNoYXBlVHlwZSB8fCAhc2hhcGVQYXJhbXMpIHJldHVybjtcblxuICAgIGxldCBzaGFwZUJvdW5kczogeyBtaW5YOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtYXhZOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgaWYgKHNoYXBlVHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgIHNoYXBlQm91bmRzID0ge1xuICAgICAgICBtaW5YOiBzaGFwZVBhcmFtcy54LFxuICAgICAgICBtaW5ZOiBzaGFwZVBhcmFtcy55LFxuICAgICAgICBtYXhYOiBzaGFwZVBhcmFtcy54ICsgc2hhcGVQYXJhbXMuc2l6ZSxcbiAgICAgICAgbWF4WTogc2hhcGVQYXJhbXMueSArIHNoYXBlUGFyYW1zLnNpemVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzaGFwZVR5cGUgPT09ICdsZXR0ZXInICYmIHNoYXBlUGFyYW1zLmxldHRlciAmJiBjdHgpIHtcbiAgICAgIGNvbnN0IGxldHRlcldpZHRoID0gc2hhcGVQYXJhbXMuc2l6ZSAqIDAuODtcbiAgICAgIGNvbnN0IGxldHRlckhlaWdodCA9IHNoYXBlUGFyYW1zLnNpemU7XG4gICAgICBjb25zdCBsZXR0ZXJDZW50ZXJYID0gc2hhcGVQYXJhbXMueCArIHNoYXBlUGFyYW1zLnNpemUgLyAyO1xuICAgICAgY29uc3QgbGV0dGVyQ2VudGVyWSA9IHNoYXBlUGFyYW1zLnkgKyBzaGFwZVBhcmFtcy5zaXplIC8gMjtcblxuICAgICAgc2hhcGVCb3VuZHMgPSB7XG4gICAgICAgIG1pblg6IGxldHRlckNlbnRlclggLSBsZXR0ZXJXaWR0aCAvIDIsXG4gICAgICAgIG1pblk6IGxldHRlckNlbnRlclkgLSBsZXR0ZXJIZWlnaHQgLyAyLFxuICAgICAgICBtYXhYOiBsZXR0ZXJDZW50ZXJYICsgbGV0dGVyV2lkdGggLyAyLFxuICAgICAgICBtYXhZOiBsZXR0ZXJDZW50ZXJZICsgbGV0dGVySGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFzaGFwZUJvdW5kcykgcmV0dXJuO1xuXG4gICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGUpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgcGFydGljbGUucG9zLnggPiBzaGFwZUJvdW5kcy5taW5YICYmXG4gICAgICAgIHBhcnRpY2xlLnBvcy54IDwgc2hhcGVCb3VuZHMubWF4WCAmJlxuICAgICAgICBwYXJ0aWNsZS5wb3MueSA+IHNoYXBlQm91bmRzLm1pblkgJiZcbiAgICAgICAgcGFydGljbGUucG9zLnkgPCBzaGFwZUJvdW5kcy5tYXhZXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZHhNaW4gPSBwYXJ0aWNsZS5wb3MueCAtIHNoYXBlQm91bmRzLm1pblg7XG4gICAgICAgIGNvbnN0IGR4TWF4ID0gc2hhcGVCb3VuZHMubWF4WCAtIHBhcnRpY2xlLnBvcy54O1xuICAgICAgICBjb25zdCBkeU1pbiA9IHBhcnRpY2xlLnBvcy55IC0gc2hhcGVCb3VuZHMubWluWTtcbiAgICAgICAgY29uc3QgZHlNYXggPSBzaGFwZUJvdW5kcy5tYXhZIC0gcGFydGljbGUucG9zLnk7XG5cbiAgICAgICAgY29uc3QgbWluRGlzdCA9IE1hdGgubWluKGR4TWluLCBkeE1heCwgZHlNaW4sIGR5TWF4KTtcbiAgICAgICAgY29uc3QgcHVzaEZvcmNlID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgbGV0IG92ZXJsYXAgPSAwO1xuXG4gICAgICAgIGlmIChtaW5EaXN0ID09PSBkeE1pbikgeyBwdXNoRm9yY2Uuc2V0KC0xLCAwKTsgb3ZlcmxhcCA9IGR4TWluOyB9XG4gICAgICAgIGVsc2UgaWYgKG1pbkRpc3QgPT09IGR4TWF4KSB7IHB1c2hGb3JjZS5zZXQoMSwgMCk7IG92ZXJsYXAgPSBkeE1heDsgfVxuICAgICAgICBlbHNlIGlmIChtaW5EaXN0ID09PSBkeU1pbikgeyBwdXNoRm9yY2Uuc2V0KDAsIC0xKTsgb3ZlcmxhcCA9IGR5TWluOyB9XG4gICAgICAgIGVsc2UgeyBwdXNoRm9yY2Uuc2V0KDAsIDEpOyBvdmVybGFwID0gZHlNYXg7IH1cblxuICAgICAgICAvLyBBcHBseSBhIHNtYWxsZXIsIGNvbnRpbnVvdXMgZm9yY2VcbiAgICAgICAgcHVzaEZvcmNlLm11bHRpcGx5U2NhbGFyKDAuMik7IC8vIFNtYWxsZXIgcHVzaCBzdHJlbmd0aFxuICAgICAgICBwYXJ0aWNsZS5hcHBseUZvcmNlKHB1c2hGb3JjZSk7XG5cbiAgICAgICAgLy8gQXBwbHkgZGFtcGluZyBvbiBjb2xsaXNpb25cbiAgICAgICAgcGFydGljbGUudmVsLm11bHRpcGx5U2NhbGFyKDAuNSk7IC8vIFN0cm9uZ2VyIGRhbXBpbmcgb24gc3RhdGljIGNvbGxpc2lvblxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZmlsbENvbG9yOiBzdHJpbmcsIHN0cm9rZUNvbG9yOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIC8vIEVuc3VyZSBmaXJzdCBwYXJ0aWNsZSBleGlzdHMgYmVmb3JlIG1vdmluZyB0byBpdFxuICAgIGlmICghdGhpcy5wYXJ0aWNsZXNbMF0/LnBvcykge1xuICAgICAgY29uc29sZS53YXJuKFwiRmlyc3QgcGFydGljbGUgbWlzc2luZyBpbiBkcmF3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHgubW92ZVRvKHRoaXMucGFydGljbGVzWzBdLnBvcy54LCB0aGlzLnBhcnRpY2xlc1swXS5wb3MueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGkgJSB0aGlzLmVkZ2VQb2ludENvdW50O1xuICAgICAgaWYgKHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0/LnBvcykge1xuICAgICAgICBjdHgubGluZVRvKHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0ucG9zLngsIHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0ucG9zLnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJ0aWNsZSBvciBwb3NpdGlvbiB1bmRlZmluZWQgYXQgaW5kZXggJHtjdXJyZW50SW5kZXh9IGR1cmluZyBkcmF3YCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTsgLy8gQ2xvc2UgcGF0aCBhZnRlciBsb29wXG5cbiAgICAvLyBDaGVjayBjb250ZXh0IHN0YXRlIGJlZm9yZSBmaWxsaW5nL3N0cm9raW5nXG4gICAgaWYgKGN0eC5maWxsU3R5bGUgIT09IGZpbGxDb2xvcikgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSBzdHJva2VDb2xvcikgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyBHZXQgU1ZHIHBhdGggZGF0YSBmb3IgdGhpcyBibG9iXG4gIGdldFNWR1BhdGgoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoIDwgMikgcmV0dXJuIFwiXCI7XG5cbiAgICBsZXQgcGF0aCA9IGBNICR7dGhpcy5wYXJ0aWNsZXNbMF0ucG9zLngudG9GaXhlZCgyKX0gJHt0aGlzLnBhcnRpY2xlc1swXS5wb3MueS50b0ZpeGVkKDIpfWA7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaSAlIHRoaXMuZWRnZVBvaW50Q291bnRdO1xuICAgICAgaWYgKHBhcnRpY2xlPy5wb3MpIHtcbiAgICAgICAgcGF0aCArPSBgIEwgJHtwYXJ0aWNsZS5wb3MueC50b0ZpeGVkKDIpfSAke3BhcnRpY2xlLnBvcy55LnRvRml4ZWQoMil9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFydGljbGUgb3IgcG9zaXRpb24gdW5kZWZpbmVkIGF0IGluZGV4ICR7aSAlIHRoaXMuZWRnZVBvaW50Q291bnR9IGR1cmluZyBTVkcgcGF0aCBnZW5lcmF0aW9uYCk7XG4gICAgICAgIHJldHVybiBwYXRoICsgXCIgWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGggKz0gXCIgWlwiO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgdXBkYXRlKFxuICAgIGJsb2JzOiBCbG9iW10sXG4gICAgc3ByaW5nVGVuc2lvbjogbnVtYmVyLFxuICAgIGNhbnZhc1dpZHRoOiBudW1iZXIsXG4gICAgY2FudmFzSGVpZ2h0OiBudW1iZXIsXG4gICAgbWFyZ2luOiBudW1iZXIsXG4gICAgaXNSb3VuZGVkQ29udGFpbmVyOiBib29sZWFuLFxuICAgIGludGVyYWN0aW9uU3RyZW5ndGg6IG51bWJlcixcbiAgICBtYXhFeHBhbnNpb25GYWN0b3I6IG51bWJlcixcbiAgICBncmF2aXR5OiBudW1iZXIsXG4gICAgZGFtcGluZzogbnVtYmVyLFxuICAgIHN0YXRpY1NoYXBlVHlwZTogJ3JlY3RhbmdsZScgfCAnbGV0dGVyJyB8IG51bGwsXG4gICAgc3RhdGljU2hhcGVQYXJhbXM6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHNpemU6IG51bWJlcjsgbGV0dGVyPzogc3RyaW5nIH0gfCBudWxsLFxuICAgIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbFxuICApIHtcbiAgICAvLyAtLS0gRm9yY2UgQXBwbGljYXRpb24gUGhhc2UgLS0tXG4gICAgLy8gQXBwbHkgaW50ZXJuYWwgZm9yY2VzIGZpcnN0IChwcmVzc3VyZSwgc3ByaW5ncylcbiAgICB0aGlzLm1haW50YWluUHJlc3N1cmUoKTtcbiAgICB0aGlzLnNwcmluZ3MuZm9yRWFjaCgoc3ByaW5nKSA9PiBzcHJpbmcudXBkYXRlKHNwcmluZ1RlbnNpb24pKTtcblxuICAgIC8vIEFwcGx5IGV4dGVybmFsIGZvcmNlcyAoZ3Jhdml0eSwgaW50ZXItYmxvYiByZXB1bHNpb24sIHN0YXRpYyBjb2xsaXNpb24pXG4gICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGUpID0+IHtcbiAgICAgIHBhcnRpY2xlLmFwcGx5Rm9yY2UobmV3IFZlY3RvcjIoMCwgZ3Jhdml0eSAqIDAuMSkpOyAvLyBBcHBseSBncmF2aXR5IHBlciBwYXJ0aWNsZVxuICAgIH0pO1xuICAgIHRoaXMucmVwZWxCbG9icyhibG9icywgaW50ZXJhY3Rpb25TdHJlbmd0aCk7XG4gICAgaWYgKGN0eCAmJiBzdGF0aWNTaGFwZVR5cGUgJiYgc3RhdGljU2hhcGVQYXJhbXMpIHtcbiAgICAgIHRoaXMuY29sbGlkZVdpdGhTdGF0aWNTaGFwZShjdHgsIHN0YXRpY1NoYXBlVHlwZSwgc3RhdGljU2hhcGVQYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIC0tLSBVcGRhdGUgUGhhc2UgLS0tXG4gICAgLy8gVXBkYXRlIHBhcnRpY2xlcyB1c2luZyBhcHBsaWVkIGZvcmNlcyBhbmQgZGFtcGluZ1xuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlKSA9PiB7XG4gICAgICBwYXJ0aWNsZS51cGRhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgbWFyZ2luLCBpc1JvdW5kZWRDb250YWluZXIsIGRhbXBpbmcpO1xuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGJsb2Igc3RhdGUgYmFzZWQgb24gbmV3IHBhcnRpY2xlIHBvc2l0aW9uc1xuICAgIHRoaXMudXBkYXRlQ2VudHJlKCk7XG4gICAgdGhpcy51cGRhdGVNYXhSYWRpdXMoKTtcblxuICAgIC8vIEFwcGx5IGdyb3d0aCBhZnRlciB1cGRhdGVzXG4gICAgdGhpcy5ncm93KG1heEV4cGFuc2lvbkZhY3Rvcik7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMiIsIlBhcnRpY2xlIiwiU3ByaW5nIiwidGVtcFZlYyIsIkJsb2IiLCJzZXR1cCIsInBhcnRpY2xlcyIsImxlbmd0aCIsInNwcmluZ3MiLCJzYWZlUmFkaXVzIiwibWF4UmFkaXVzIiwiYW5nbGVTdGVwIiwiTWF0aCIsIlBJIiwiZWRnZVBvaW50Q291bnQiLCJpbml0aWFsU3ByaW5nTGVuZ3RoIiwibWF4Iiwic2luIiwiaSIsImFuZ2xlIiwieCIsImNvcyIsImNlbnRyZSIsInkiLCJwdXNoIiwidXBkYXRlQ2VudHJlIiwic2V0IiwiZm9yRWFjaCIsInAiLCJhZGQiLCJwb3MiLCJkaXZpZGVTY2FsYXIiLCJ1cGRhdGVNYXhSYWRpdXMiLCJtYXhEaXN0U3EiLCJwYXJ0aWNsZSIsImRpc3RTcSIsImRpc3RhbmNlVG9TcXVhcmVkIiwic3FydCIsInJlcGVsQmxvYnMiLCJibG9icyIsImludGVyYWN0aW9uU3RyZW5ndGgiLCJibG9iQiIsImlkIiwiZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSIsInJlcGVsRGlzdGFuY2UiLCJkaXN0QmV0d2VlbkNlbnRlcnNTcSIsImNvbWJpbmVkUmFkaWkiLCJpbnRlcmFjdGlvblJhbmdlU3EiLCJwb3ciLCJwYXJ0aWNsZUEiLCJwYXJ0aWNsZUIiLCJjb3B5Iiwic3ViIiwibGVuZ3RoU3EiLCJyZXBlbERpc3RTcSIsImRpc3QiLCJvdmVybGFwIiwiZm9yY2VNYWduaXR1ZGUiLCJtaW4iLCJtYXhSZXB1bHNpb25Gb3JjZSIsIm11bHRpcGx5U2NhbGFyIiwiYXBwbHlGb3JjZSIsImFyZWEiLCJ0b3RhbCIsInAxIiwicDIiLCJhYnMiLCJncm93IiwibWF4RXhwYW5zaW9uRmFjdG9yIiwiaW5pdGlhbEFyZWEiLCJtYXhUYXJnZXRBcmVhIiwidGFyZ2V0QXJlYSIsIm1haW50YWluUHJlc3N1cmUiLCJjdXJyZW50QXJlYSIsImFyZWFSYXRpbyIsImNsYW1wZWRSYXRpbyIsInByZXNzdXJlRGlmZmVyZW5jZSIsImZvcmNlU2l6ZSIsInByZXNzdXJlQ29uc3RhbnQiLCJtYXhQcmVzc3VyZUZvcmNlIiwiY2FwcGVkRm9yY2VTaXplIiwicHJldiIsIm5leHQiLCJ0b1ByZXYiLCJ0b05leHQiLCJlZGdlVmVjdG9yIiwib3V0d2FyZE5vcm1hbCIsIm5vcm1hbGl6ZSIsImNvbGxpZGVXaXRoU3RhdGljU2hhcGUiLCJjdHgiLCJzaGFwZVR5cGUiLCJzaGFwZVBhcmFtcyIsInNoYXBlQm91bmRzIiwibWluWCIsIm1pblkiLCJtYXhYIiwic2l6ZSIsIm1heFkiLCJsZXR0ZXIiLCJsZXR0ZXJXaWR0aCIsImxldHRlckhlaWdodCIsImxldHRlckNlbnRlclgiLCJsZXR0ZXJDZW50ZXJZIiwiZHhNaW4iLCJkeE1heCIsImR5TWluIiwiZHlNYXgiLCJtaW5EaXN0IiwicHVzaEZvcmNlIiwidmVsIiwiZHJhdyIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwiYmVnaW5QYXRoIiwiY29uc29sZSIsIndhcm4iLCJtb3ZlVG8iLCJjdXJyZW50SW5kZXgiLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJmaWxsU3R5bGUiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImZpbGwiLCJzdHJva2UiLCJnZXRTVkdQYXRoIiwicGF0aCIsInRvRml4ZWQiLCJ1cGRhdGUiLCJzcHJpbmdUZW5zaW9uIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJtYXJnaW4iLCJpc1JvdW5kZWRDb250YWluZXIiLCJncmF2aXR5IiwiZGFtcGluZyIsInN0YXRpY1NoYXBlVHlwZSIsInN0YXRpY1NoYXBlUGFyYW1zIiwic3ByaW5nIiwiY29uc3RydWN0b3IiLCJzdGFydFNpemUiLCJyYW5kb20iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/blob-simulation/blob.ts\n"));

/***/ })

});