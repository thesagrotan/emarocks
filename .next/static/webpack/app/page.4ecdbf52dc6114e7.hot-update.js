"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/blob-simulation/blob.ts":
/*!********************************************!*\
  !*** ./components/blob-simulation/blob.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./particle */ \"(app-pages-browser)/./components/blob-simulation/particle.ts\");\n/* harmony import */ var _spring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spring */ \"(app-pages-browser)/./components/blob-simulation/spring.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./components/blob-simulation/utils.ts\");\n\n\n\n // Import the isPointInLetter function\n// Temporary vector for calculations\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();\n// Blob Class - represents a complete blob with particles and springs\nclass Blob {\n    setup() {\n        this.particles.length = 0;\n        this.springs.length = 0;\n        const safeRadius = this.maxRadius; // Already ensured > 0 in constructor\n        const angleStep = Math.PI * 2 / this.edgePointCount;\n        // Ensure initialSpringLength is positive and reasonable\n        const initialSpringLength = Math.max(1e-6, safeRadius * Math.sin(Math.PI / this.edgePointCount) * 2);\n        for(let i = 0; i < this.edgePointCount; i++){\n            const angle = i * angleStep;\n            const x = Math.cos(angle) * safeRadius + this.centre.x;\n            const y = Math.sin(angle) * safeRadius + this.centre.y;\n            this.particles.push(new _particle__WEBPACK_IMPORTED_MODULE_0__.Particle(x, y));\n            if (i > 0) {\n                this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[i], this.particles[i - 1], initialSpringLength));\n            }\n        }\n        this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[0], this.particles[this.edgePointCount - 1], initialSpringLength));\n    }\n    updateCentre() {\n        if (this.particles.length === 0) return;\n        this.centre.set(0, 0);\n        this.particles.forEach((p)=>this.centre.add(p.pos));\n        this.centre.divideScalar(this.particles.length);\n    }\n    updateMaxRadius() {\n        if (this.particles.length === 0) {\n            this.maxRadius = 0;\n            return;\n        }\n        let maxDistSq = 0;\n        this.particles.forEach((particle)=>{\n            const distSq = this.centre.distanceToSquared(particle.pos);\n            if (distSq > maxDistSq) maxDistSq = distSq;\n        });\n        this.maxRadius = Math.sqrt(maxDistSq);\n    }\n    // Repel other blobs\n    repelBlobs(blobs, interactionStrength) {\n        blobs.forEach((blobB)=>{\n            if (this.id === blobB.id) return;\n            // Use the same repelDistance for both blobs to ensure consistency\n            const effectiveRepelDistance = Math.max(this.repelDistance, blobB.repelDistance);\n            const distBetweenCentersSq = this.centre.distanceToSquared(blobB.centre);\n            // Use radii squared for comparison to avoid sqrt\n            const combinedRadii = this.maxRadius + blobB.maxRadius;\n            const interactionRangeSq = Math.pow(combinedRadii + effectiveRepelDistance, 2);\n            // Optimization: Broad phase check based on centers and radii + repel distance\n            if (distBetweenCentersSq > interactionRangeSq) return;\n            // Narrow phase: Check particle pairs\n            this.particles.forEach((particleA)=>{\n                blobB.particles.forEach((particleB)=>{\n                    tempVec.copy(particleA.pos).sub(particleB.pos);\n                    const distSq = tempVec.lengthSq(); // Use squared distance\n                    // Apply repulsion force if within repelDistance squared\n                    const repelDistSq = effectiveRepelDistance * effectiveRepelDistance;\n                    if (distSq > 1e-12 && distSq < repelDistSq) {\n                        const dist = Math.sqrt(distSq);\n                        const overlap = effectiveRepelDistance - dist;\n                        // Calculate force magnitude based on overlap and strength\n                        let forceMagnitude = overlap * interactionStrength;\n                        // Cap the force magnitude\n                        forceMagnitude = Math.min(forceMagnitude, this.maxRepulsionForce);\n                        // Normalize direction vector (reuse tempVec) and apply magnitude\n                        tempVec.multiplyScalar(forceMagnitude / dist);\n                        // Apply forces ensuring they are finite\n                        particleA.applyForce(tempVec);\n                        particleB.applyForce(tempVec.multiplyScalar(-1)); // Apply opposite force\n                    }\n                });\n            });\n        });\n    }\n    get area() {\n        let total = 0;\n        if (this.particles.length < 3) return 0;\n        for(let i = 0; i < this.edgePointCount; i++){\n            const p1 = this.particles[i].pos;\n            const p2 = this.particles[(i + 1) % this.edgePointCount].pos;\n            total += p1.x * p2.y - p2.x * p1.y;\n        }\n        return Math.abs(total / 2);\n    }\n    grow(maxExpansionFactor) {\n        if (this.initialArea <= 0) return;\n        const maxTargetArea = this.initialArea * Math.max(1, maxExpansionFactor);\n        if (this.targetArea < maxTargetArea) {\n            this.targetArea *= 1.005; // Slow growth\n            this.targetArea = Math.min(this.targetArea, maxTargetArea); // Clamp to max\n        } else if (this.targetArea > maxTargetArea) {\n            this.targetArea = maxTargetArea;\n        }\n    }\n    maintainPressure() {\n        const currentArea = this.area;\n        if (currentArea < 1e-6 || this.targetArea < 1e-6) return;\n        // Make pressure force proportional to the difference ratio, but prevent extreme forces\n        const areaRatio = this.targetArea / currentArea;\n        // Clamp the ratio to prevent excessive forces when area is very small\n        const clampedRatio = Math.max(0.5, Math.min(areaRatio, 2.0));\n        const pressureDifference = clampedRatio - 1;\n        const forceSize = pressureDifference * this.pressureConstant;\n        // Limit the maximum force size to prevent instability\n        const maxPressureForce = 0.1; // Example cap\n        const cappedForceSize = Math.max(-maxPressureForce, Math.min(forceSize, maxPressureForce));\n        this.particles.forEach((particle, i)=>{\n            const prev = this.particles[(i + this.edgePointCount - 1) % this.edgePointCount];\n            const next = this.particles[(i + 1) % this.edgePointCount];\n            // Calculate edge vectors from the particle to its neighbors\n            const toPrev = tempVec.copy(prev.pos).sub(particle.pos);\n            const toNext = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2().copy(next.pos).sub(particle.pos); // Use a separate Vector2 instance\n            // Calculate outward normal using the cross product concept (for 2D)\n            const edgeVector = toNext.sub(toPrev); // Vector along the edge (next - prev)\n            const outwardNormal = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(-edgeVector.y, edgeVector.x); // Perpendicular vector\n            if (outwardNormal.lengthSq() < 1e-12) return; // Skip if normal is zero length\n            outwardNormal.normalize();\n            outwardNormal.multiplyScalar(cappedForceSize);\n            particle.applyForce(outwardNormal);\n        });\n    }\n    // Collision with Static Obstacles\n    collideWithStaticShape(ctx, shapeType, shapeParams) {\n        console.log(\"collideWithStaticShape called\");\n        if (!shapeType || !shapeParams || !shapeParams.letter) return;\n        // For letter shapes\n        if (shapeType === 'letter' && shapeParams.letter) {\n            const letterCenterX = shapeParams.x + shapeParams.size / 2;\n            const letterCenterY = shapeParams.y + shapeParams.size / 2;\n            // Cache letter bounds for optimization\n            const letterBounds = {\n                minX: shapeParams.x,\n                minY: shapeParams.y,\n                maxX: shapeParams.x + shapeParams.size,\n                maxY: shapeParams.y + shapeParams.size\n            };\n            // Check ALL particles for collision with the letter shape\n            for(let i = 0; i < this.particles.length; i++){\n                const particle = this.particles[i];\n                // Quick bounds check first (simple optimization)\n                if (particle.pos.x >= letterBounds.minX - 5 && particle.pos.x <= letterBounds.maxX + 5 && particle.pos.y >= letterBounds.minY - 5 && particle.pos.y <= letterBounds.maxY + 5) {\n                    // Test if particle is actually inside the letter shape\n                    const isInside = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isPointInLetter)(ctx, shapeParams.letter, letterCenterX, letterCenterY, shapeParams.size, particle.pos.x, particle.pos.y);\n                    if (isInside) {\n                        // Calculate vector from center of letter to particle\n                        const toParticle = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(particle.pos.x - letterCenterX, particle.pos.y - letterCenterY);\n                        // If vector is near zero, use a random direction\n                        if (toParticle.lengthSq() < 0.1) {\n                            const randomAngle = Math.random() * Math.PI * 2;\n                            toParticle.set(Math.cos(randomAngle), Math.sin(randomAngle));\n                        }\n                        // Normalize \n                        toParticle.normalize();\n                        // Check if the particle is within an enclosed space\n                        const isEnclosed = (()=>{\n                            const rayCount = 32;\n                            const rayLength = shapeParams.size * 0.75;\n                            let intersectionCount = 0;\n                            for(let i = 0; i < rayCount; i++){\n                                const angle = i / rayCount * Math.PI * 2;\n                                const rayX = particle.pos.x + Math.cos(angle) * rayLength;\n                                const rayY = particle.pos.y + Math.sin(angle) * rayLength;\n                                if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.isPointInLetter)(ctx, shapeParams.letter, letterCenterX, letterCenterY, shapeParams.size, rayX, rayY)) {\n                                    intersectionCount++;\n                                }\n                            }\n                            return intersectionCount / rayCount >= 0.75;\n                        })();\n                        // Modify repulsion direction if within an enclosed space\n                        if (isEnclosed) {\n                            // Invert the direction to guide the particle inwards\n                            toParticle.multiplyScalar(-1);\n                            // Use a strong push force\n                            const pushForce = 5.0;\n                            toParticle.multiplyScalar(pushForce);\n                            // Apply this strong force to immediately push the particle \n                            particle.applyForce(toParticle);\n                            // Also directly modify velocity to ensure immediate response\n                            const escapeVelocity = toParticle.clone().multiplyScalar(0.5);\n                            particle.vel.add(escapeVelocity);\n                            // Apply strong damping to other directions to prevent oscillation\n                            const dampingFactor = 0.5;\n                            particle.vel.multiplyScalar(dampingFactor);\n                        }\n                    } else {\n                        // Not inside, reset stuck counter if it exists\n                        if (particle.stuckFrames !== undefined) {\n                            particle.stuckFrames = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    draw(ctx, fillColor, strokeColor, staticShapeType, staticShapeParams) {\n        var _this_particles_;\n        if (this.particles.length < 2) return;\n        ctx.beginPath();\n        // Ensure first particle exists before moving to it\n        if (!((_this_particles_ = this.particles[0]) === null || _this_particles_ === void 0 ? void 0 : _this_particles_.pos)) {\n            console.warn(\"First particle missing in draw\");\n            return;\n        }\n        ctx.moveTo(this.particles[0].pos.x, this.particles[0].pos.y);\n        for(let i = 1; i <= this.edgePointCount; i++){\n            var _this_particles_currentIndex;\n            const currentIndex = i % this.edgePointCount;\n            if ((_this_particles_currentIndex = this.particles[currentIndex]) === null || _this_particles_currentIndex === void 0 ? void 0 : _this_particles_currentIndex.pos) {\n                ctx.lineTo(this.particles[currentIndex].pos.x, this.particles[currentIndex].pos.y);\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(currentIndex, \" during draw\"));\n                ctx.closePath();\n                break;\n            }\n        }\n        ctx.closePath(); // Close path after loop\n        // Check context state before filling/stroking\n        if (ctx.fillStyle !== fillColor) ctx.fillStyle = fillColor;\n        if (ctx.strokeStyle !== strokeColor) ctx.strokeStyle = strokeColor;\n        ctx.lineWidth = 1;\n        ctx.fill();\n        ctx.stroke();\n    }\n    // Get SVG path data for this blob\n    getSVGPath() {\n        if (this.particles.length < 2) return \"\";\n        let path = \"M \".concat(this.particles[0].pos.x.toFixed(2), \" \").concat(this.particles[0].pos.y.toFixed(2));\n        for(let i = 1; i <= this.edgePointCount; i++){\n            const particle = this.particles[i % this.edgePointCount];\n            if (particle === null || particle === void 0 ? void 0 : particle.pos) {\n                path += \" L \".concat(particle.pos.x.toFixed(2), \" \").concat(particle.pos.y.toFixed(2));\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(i % this.edgePointCount, \" during SVG path generation\"));\n                return path + \" Z\";\n            }\n        }\n        path += \" Z\";\n        return path;\n    }\n    update(blobs, springTension, canvasWidth, canvasHeight, margin, isRoundedContainer, interactionStrength, maxExpansionFactor, gravity, damping, staticShapeType, staticShapeParams, ctx) {\n        // --- Force Application Phase ---\n        // Apply internal forces first (pressure, springs)\n        this.maintainPressure();\n        this.springs.forEach((spring)=>spring.update(springTension));\n        // Apply external forces (gravity, inter-blob repulsion, static collision)\n        this.particles.forEach((particle)=>{\n            particle.applyForce(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, gravity * 0.1)); // Apply gravity per particle\n        });\n        this.repelBlobs(blobs, interactionStrength);\n        if (ctx && staticShapeType && staticShapeParams) {\n            this.collideWithStaticShape(ctx, staticShapeType, staticShapeParams);\n        }\n        // --- [DEBUG] Draw rays for enclosed space check ---\n        if (ctx && staticShapeType === 'letter' && staticShapeParams && staticShapeParams.letter) {\n            const letterCenterX = staticShapeParams.x + staticShapeParams.size / 2;\n            const letterCenterY = staticShapeParams.y + staticShapeParams.size / 2;\n            const { size, letter } = staticShapeParams;\n            const rayCount = 16;\n            const rayLength = size * 0.5;\n            for(let i = 0; i < rayCount; i++){\n                const angle = i / rayCount * Math.PI * 2;\n                const rayX = this.centre.x + Math.cos(angle) * rayLength;\n                const rayY = this.centre.y + Math.sin(angle) * rayLength;\n                ctx.beginPath();\n                ctx.moveTo(this.centre.x, this.centre.y);\n                ctx.lineTo(rayX, rayY);\n                ctx.strokeStyle = 'red';\n                ctx.lineWidth = 0.5;\n                ctx.stroke();\n            }\n        }\n        // --- [DEBUG] End draw rays for enclosed space check ---\n        // --- Update Phase ---\n        // Update particles using applied forces and damping\n        this.particles.forEach((particle)=>{\n            particle.update(canvasWidth, canvasHeight, margin, isRoundedContainer, damping);\n        });\n        // Update blob state based on new particle positions\n        this.updateCentre();\n        this.updateMaxRadius();\n        // Apply growth after updates\n        this.grow(maxExpansionFactor);\n    }\n    constructor(x, y, edgePointCount, startSize, repelDistance){\n        this.pressureConstant = 0.08 // Pressure constant\n        ;\n        this.maxRepulsionForce = 0.5 // Cap for repulsion force magnitude\n        ;\n        this.id = Math.random();\n        this.centre = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(x, y);\n        this.edgePointCount = edgePointCount;\n        this.particles = [];\n        this.springs = [];\n        this.maxRadius = Math.max(1, startSize); // Ensure startSize is at least 1\n        this.initialArea = Math.PI * this.maxRadius * this.maxRadius;\n        this.targetArea = this.initialArea;\n        this.repelDistance = repelDistance;\n        this.setup();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYmxvYi1zaW11bGF0aW9uL2Jsb2IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0M7QUFDTTtBQUNKO0FBQ1EsQ0FBQyxzQ0FBc0M7QUFFakYsb0NBQW9DO0FBQ3BDLE1BQU1JLFVBQVUsSUFBSUosMENBQU9BO0FBRTNCLHFFQUFxRTtBQUM5RCxNQUFNSztJQTBCWEMsUUFBUTtRQUNOLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxPQUFPLENBQUNELE1BQU0sR0FBRztRQUV0QixNQUFNRSxhQUFhLElBQUksQ0FBQ0MsU0FBUyxFQUFFLHFDQUFxQztRQUN4RSxNQUFNQyxZQUFZLEtBQU1FLEVBQUUsR0FBRyxJQUFLLElBQUksQ0FBQ0MsY0FBYztRQUNyRCx3REFBd0Q7UUFDeEQsTUFBTUMsc0JBQXNCSCxLQUFLSSxHQUFHLENBQUMsTUFBTVAsYUFBYUcsS0FBS0ssR0FBRyxDQUFDTCxLQUFLQyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxjQUFjLElBQUk7UUFFbEcsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixjQUFjLEVBQUVJLElBQUs7WUFDNUMsTUFBTUMsUUFBUUQsSUFBSVA7WUFDbEIsTUFBTVMsSUFBSVIsS0FBS1MsR0FBRyxDQUFDRixTQUFTVixhQUFhLElBQUksQ0FBQ2EsTUFBTSxDQUFDRixDQUFDO1lBQ3RELE1BQU1HLElBQUlYLEtBQUtLLEdBQUcsQ0FBQ0UsU0FBU1YsYUFBYSxJQUFJLENBQUNhLE1BQU0sQ0FBQ0MsQ0FBQztZQUN0RCxJQUFJLENBQUNqQixTQUFTLENBQUNrQixJQUFJLENBQUMsSUFBSXhCLCtDQUFRQSxDQUFDb0IsR0FBR0c7WUFFcEMsSUFBSUwsSUFBSSxHQUFHO2dCQUNULElBQUksQ0FBQ1YsT0FBTyxDQUFDZ0IsSUFBSSxDQUFDLElBQUl2QiwyQ0FBTUEsQ0FBQyxJQUFJLENBQUNLLFNBQVMsQ0FBQ1ks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O1FBQ3JCLElBQUksQ0FBQ3ZDLEtBQUs7SUFDWjtBQW9YRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhbmllbC9EZXZlbG9wZXIvZW1hcm9ja3MvY29tcG9uZW50cy9ibG9iLXNpbXVsYXRpb24vYmxvYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBQYXJ0aWNsZSB9IGZyb20gXCIuL3BhcnRpY2xlXCI7XG5pbXBvcnQgeyBTcHJpbmcgfSBmcm9tIFwiLi9zcHJpbmdcIjtcbmltcG9ydCB7IGlzUG9pbnRJbkxldHRlciB9IGZyb20gXCIuL3V0aWxzXCI7IC8vIEltcG9ydCB0aGUgaXNQb2ludEluTGV0dGVyIGZ1bmN0aW9uXG5cbi8vIFRlbXBvcmFyeSB2ZWN0b3IgZm9yIGNhbGN1bGF0aW9uc1xuY29uc3QgdGVtcFZlYyA9IG5ldyBWZWN0b3IyKCk7XG5cbi8vIEJsb2IgQ2xhc3MgLSByZXByZXNlbnRzIGEgY29tcGxldGUgYmxvYiB3aXRoIHBhcnRpY2xlcyBhbmQgc3ByaW5nc1xuZXhwb3J0IGNsYXNzIEJsb2Ige1xuICBjZW50cmU6IFZlY3RvcjI7XG4gIG1heFJhZGl1czogbnVtYmVyOyAvLyBEeW5hbWljIHJhZGl1cyBiYXNlZCBvbiBwYXJ0aWNsZSBwb3NpdGlvbnNcbiAgZWRnZVBvaW50Q291bnQ6IG51bWJlcjtcbiAgcGFydGljbGVzOiBQYXJ0aWNsZVtdO1xuICBzcHJpbmdzOiBTcHJpbmdbXTtcblxuICBpbml0aWFsQXJlYTogbnVtYmVyO1xuICB0YXJnZXRBcmVhOiBudW1iZXI7XG4gIHJlcGVsRGlzdGFuY2U6IG51bWJlcjtcbiAgcHJlc3N1cmVDb25zdGFudDogbnVtYmVyID0gMC4wODsgLy8gUHJlc3N1cmUgY29uc3RhbnRcbiAgbWF4UmVwdWxzaW9uRm9yY2U6IG51bWJlciA9IDAuNTsgLy8gQ2FwIGZvciByZXB1bHNpb24gZm9yY2UgbWFnbml0dWRlXG4gIGlkOiBudW1iZXIgPSBNYXRoLnJhbmRvbSgpO1xuXG4gIGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCBlZGdlUG9pbnRDb3VudDogbnVtYmVyLCBzdGFydFNpemU6IG51bWJlciwgcmVwZWxEaXN0YW5jZTogbnVtYmVyKSB7XG4gICAgdGhpcy5jZW50cmUgPSBuZXcgVmVjdG9yMih4LCB5KTtcbiAgICB0aGlzLmVkZ2VQb2ludENvdW50ID0gZWRnZVBvaW50Q291bnQ7XG4gICAgdGhpcy5wYXJ0aWNsZXMgPSBbXTtcbiAgICB0aGlzLnNwcmluZ3MgPSBbXTtcbiAgICB0aGlzLm1heFJhZGl1cyA9IE1hdGgubWF4KDEsIHN0YXJ0U2l6ZSk7IC8vIEVuc3VyZSBzdGFydFNpemUgaXMgYXQgbGVhc3QgMVxuICAgIHRoaXMuaW5pdGlhbEFyZWEgPSBNYXRoLlBJICogdGhpcy5tYXhSYWRpdXMgKiB0aGlzLm1heFJhZGl1cztcbiAgICB0aGlzLnRhcmdldEFyZWEgPSB0aGlzLmluaXRpYWxBcmVhO1xuICAgIHRoaXMucmVwZWxEaXN0YW5jZSA9IHJlcGVsRGlzdGFuY2U7XG4gICAgdGhpcy5zZXR1cCgpO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNwcmluZ3MubGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IHNhZmVSYWRpdXMgPSB0aGlzLm1heFJhZGl1czsgLy8gQWxyZWFkeSBlbnN1cmVkID4gMCBpbiBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IGFuZ2xlU3RlcCA9IChNYXRoLlBJICogMikgLyB0aGlzLmVkZ2VQb2ludENvdW50O1xuICAgIC8vIEVuc3VyZSBpbml0aWFsU3ByaW5nTGVuZ3RoIGlzIHBvc2l0aXZlIGFuZCByZWFzb25hYmxlXG4gICAgY29uc3QgaW5pdGlhbFNwcmluZ0xlbmd0aCA9IE1hdGgubWF4KDFlLTYsIHNhZmVSYWRpdXMgKiBNYXRoLnNpbihNYXRoLlBJIC8gdGhpcy5lZGdlUG9pbnRDb3VudCkgKiAyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlUG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBhbmdsZVN0ZXA7XG4gICAgICBjb25zdCB4ID0gTWF0aC5jb3MoYW5nbGUpICogc2FmZVJhZGl1cyArIHRoaXMuY2VudHJlLng7XG4gICAgICBjb25zdCB5ID0gTWF0aC5zaW4oYW5nbGUpICogc2FmZVJhZGl1cyArIHRoaXMuY2VudHJlLnk7XG4gICAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKG5ldyBQYXJ0aWNsZSh4LCB5KSk7XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB0aGlzLnNwcmluZ3MucHVzaChuZXcgU3ByaW5nKHRoaXMucGFydGljbGVzW2ldLCB0aGlzLnBhcnRpY2xlc1tpIC0gMV0sIGluaXRpYWxTcHJpbmdMZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcHJpbmdzLnB1c2gobmV3IFNwcmluZyh0aGlzLnBhcnRpY2xlc1swXSwgdGhpcy5wYXJ0aWNsZXNbdGhpcy5lZGdlUG9pbnRDb3VudCAtIDFdLCBpbml0aWFsU3ByaW5nTGVuZ3RoKSk7XG4gIH1cblxuICB1cGRhdGVDZW50cmUoKSB7XG4gICAgaWYgKHRoaXMucGFydGljbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuY2VudHJlLnNldCgwLCAwKTtcbiAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKHAgPT4gdGhpcy5jZW50cmUuYWRkKHAucG9zKSk7XG4gICAgdGhpcy5jZW50cmUuZGl2aWRlU2NhbGFyKHRoaXMucGFydGljbGVzLmxlbmd0aCk7XG4gIH1cblxuICB1cGRhdGVNYXhSYWRpdXMoKSB7XG4gICAgaWYgKHRoaXMucGFydGljbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF4RGlzdFNxID0gMDtcbiAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSkgPT4ge1xuICAgICAgY29uc3QgZGlzdFNxID0gdGhpcy5jZW50cmUuZGlzdGFuY2VUb1NxdWFyZWQocGFydGljbGUucG9zKTtcbiAgICAgIGlmIChkaXN0U3EgPiBtYXhEaXN0U3EpIG1heERpc3RTcSA9IGRpc3RTcTtcbiAgICB9KTtcbiAgICB0aGlzLm1heFJhZGl1cyA9IE1hdGguc3FydChtYXhEaXN0U3EpO1xuICB9XG5cbiAgLy8gUmVwZWwgb3RoZXIgYmxvYnNcbiAgcmVwZWxCbG9icyhibG9iczogQmxvYltdLCBpbnRlcmFjdGlvblN0cmVuZ3RoOiBudW1iZXIpIHtcbiAgICBibG9icy5mb3JFYWNoKChibG9iQikgPT4ge1xuICAgICAgaWYgKHRoaXMuaWQgPT09IGJsb2JCLmlkKSByZXR1cm47XG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSByZXBlbERpc3RhbmNlIGZvciBib3RoIGJsb2JzIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICAgICAgY29uc3QgZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSA9IE1hdGgubWF4KHRoaXMucmVwZWxEaXN0YW5jZSwgYmxvYkIucmVwZWxEaXN0YW5jZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRpc3RCZXR3ZWVuQ2VudGVyc1NxID0gdGhpcy5jZW50cmUuZGlzdGFuY2VUb1NxdWFyZWQoYmxvYkIuY2VudHJlKTtcbiAgICAgIC8vIFVzZSByYWRpaSBzcXVhcmVkIGZvciBjb21wYXJpc29uIHRvIGF2b2lkIHNxcnRcbiAgICAgIGNvbnN0IGNvbWJpbmVkUmFkaWkgPSB0aGlzLm1heFJhZGl1cyArIGJsb2JCLm1heFJhZGl1cztcbiAgICAgIGNvbnN0IGludGVyYWN0aW9uUmFuZ2VTcSA9IE1hdGgucG93KGNvbWJpbmVkUmFkaWkgKyBlZmZlY3RpdmVSZXBlbERpc3RhbmNlLCAyKTtcblxuICAgICAgLy8gT3B0aW1pemF0aW9uOiBCcm9hZCBwaGFzZSBjaGVjayBiYXNlZCBvbiBjZW50ZXJzIGFuZCByYWRpaSArIHJlcGVsIGRpc3RhbmNlXG4gICAgICBpZiAoZGlzdEJldHdlZW5DZW50ZXJzU3EgPiBpbnRlcmFjdGlvblJhbmdlU3EpIHJldHVybjtcblxuICAgICAgLy8gTmFycm93IHBoYXNlOiBDaGVjayBwYXJ0aWNsZSBwYWlyc1xuICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGVBKSA9PiB7XG4gICAgICAgIGJsb2JCLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZUIpID0+IHtcbiAgICAgICAgICB0ZW1wVmVjLmNvcHkocGFydGljbGVBLnBvcykuc3ViKHBhcnRpY2xlQi5wb3MpO1xuICAgICAgICAgIGNvbnN0IGRpc3RTcSA9IHRlbXBWZWMubGVuZ3RoU3EoKTsgLy8gVXNlIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgICAgICAgIC8vIEFwcGx5IHJlcHVsc2lvbiBmb3JjZSBpZiB3aXRoaW4gcmVwZWxEaXN0YW5jZSBzcXVhcmVkXG4gICAgICAgICAgY29uc3QgcmVwZWxEaXN0U3EgPSBlZmZlY3RpdmVSZXBlbERpc3RhbmNlICogZWZmZWN0aXZlUmVwZWxEaXN0YW5jZTtcbiAgICAgICAgICBpZiAoZGlzdFNxID4gMWUtMTIgJiYgZGlzdFNxIDwgcmVwZWxEaXN0U3EpIHsgLy8gQ29tcGFyZSBzcXVhcmVkIGRpc3RhbmNlc1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkaXN0U3EpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IGVmZmVjdGl2ZVJlcGVsRGlzdGFuY2UgLSBkaXN0O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZm9yY2UgbWFnbml0dWRlIGJhc2VkIG9uIG92ZXJsYXAgYW5kIHN0cmVuZ3RoXG4gICAgICAgICAgICBsZXQgZm9yY2VNYWduaXR1ZGUgPSBvdmVybGFwICogaW50ZXJhY3Rpb25TdHJlbmd0aDtcblxuICAgICAgICAgICAgLy8gQ2FwIHRoZSBmb3JjZSBtYWduaXR1ZGVcbiAgICAgICAgICAgIGZvcmNlTWFnbml0dWRlID0gTWF0aC5taW4oZm9yY2VNYWduaXR1ZGUsIHRoaXMubWF4UmVwdWxzaW9uRm9yY2UpO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgZGlyZWN0aW9uIHZlY3RvciAocmV1c2UgdGVtcFZlYykgYW5kIGFwcGx5IG1hZ25pdHVkZVxuICAgICAgICAgICAgdGVtcFZlYy5tdWx0aXBseVNjYWxhcihmb3JjZU1hZ25pdHVkZSAvIGRpc3QpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBmb3JjZXMgZW5zdXJpbmcgdGhleSBhcmUgZmluaXRlXG4gICAgICAgICAgICBwYXJ0aWNsZUEuYXBwbHlGb3JjZSh0ZW1wVmVjKTtcbiAgICAgICAgICAgIHBhcnRpY2xlQi5hcHBseUZvcmNlKHRlbXBWZWMubXVsdGlwbHlTY2FsYXIoLTEpKTsgLy8gQXBwbHkgb3Bwb3NpdGUgZm9yY2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgYXJlYSgpOiBudW1iZXIge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgaWYgKHRoaXMucGFydGljbGVzLmxlbmd0aCA8IDMpIHJldHVybiAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHAxID0gdGhpcy5wYXJ0aWNsZXNbaV0ucG9zO1xuICAgICAgY29uc3QgcDIgPSB0aGlzLnBhcnRpY2xlc1soaSArIDEpICUgdGhpcy5lZGdlUG9pbnRDb3VudF0ucG9zO1xuICAgICAgdG90YWwgKz0gcDEueCAqIHAyLnkgLSBwMi54ICogcDEueTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsIC8gMik7XG4gIH1cblxuICBncm93KG1heEV4cGFuc2lvbkZhY3RvcjogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbEFyZWEgPD0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IG1heFRhcmdldEFyZWEgPSB0aGlzLmluaXRpYWxBcmVhICogTWF0aC5tYXgoMSwgbWF4RXhwYW5zaW9uRmFjdG9yKTtcblxuICAgIGlmICh0aGlzLnRhcmdldEFyZWEgPCBtYXhUYXJnZXRBcmVhKSB7XG4gICAgICB0aGlzLnRhcmdldEFyZWEgKj0gMS4wMDU7IC8vIFNsb3cgZ3Jvd3RoXG4gICAgICB0aGlzLnRhcmdldEFyZWEgPSBNYXRoLm1pbih0aGlzLnRhcmdldEFyZWEsIG1heFRhcmdldEFyZWEpOyAvLyBDbGFtcCB0byBtYXhcbiAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0QXJlYSA+IG1heFRhcmdldEFyZWEpIHtcbiAgICAgIHRoaXMudGFyZ2V0QXJlYSA9IG1heFRhcmdldEFyZWE7XG4gICAgfVxuICB9XG5cbiAgbWFpbnRhaW5QcmVzc3VyZSgpIHtcbiAgICBjb25zdCBjdXJyZW50QXJlYSA9IHRoaXMuYXJlYTtcbiAgICBpZiAoY3VycmVudEFyZWEgPCAxZS02IHx8IHRoaXMudGFyZ2V0QXJlYSA8IDFlLTYpIHJldHVybjtcblxuICAgIC8vIE1ha2UgcHJlc3N1cmUgZm9yY2UgcHJvcG9ydGlvbmFsIHRvIHRoZSBkaWZmZXJlbmNlIHJhdGlvLCBidXQgcHJldmVudCBleHRyZW1lIGZvcmNlc1xuICAgIGNvbnN0IGFyZWFSYXRpbyA9IHRoaXMudGFyZ2V0QXJlYSAvIGN1cnJlbnRBcmVhO1xuICAgIC8vIENsYW1wIHRoZSByYXRpbyB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSBmb3JjZXMgd2hlbiBhcmVhIGlzIHZlcnkgc21hbGxcbiAgICBjb25zdCBjbGFtcGVkUmF0aW8gPSBNYXRoLm1heCgwLjUsIE1hdGgubWluKGFyZWFSYXRpbywgMi4wKSk7XG4gICAgY29uc3QgcHJlc3N1cmVEaWZmZXJlbmNlID0gY2xhbXBlZFJhdGlvIC0gMTtcblxuICAgIGNvbnN0IGZvcmNlU2l6ZSA9IHByZXNzdXJlRGlmZmVyZW5jZSAqIHRoaXMucHJlc3N1cmVDb25zdGFudDtcblxuICAgIC8vIExpbWl0IHRoZSBtYXhpbXVtIGZvcmNlIHNpemUgdG8gcHJldmVudCBpbnN0YWJpbGl0eVxuICAgIGNvbnN0IG1heFByZXNzdXJlRm9yY2UgPSAwLjE7IC8vIEV4YW1wbGUgY2FwXG4gICAgY29uc3QgY2FwcGVkRm9yY2VTaXplID0gTWF0aC5tYXgoLW1heFByZXNzdXJlRm9yY2UsIE1hdGgubWluKGZvcmNlU2l6ZSwgbWF4UHJlc3N1cmVGb3JjZSkpO1xuXG4gICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnBhcnRpY2xlc1soaSArIHRoaXMuZWRnZVBvaW50Q291bnQgLSAxKSAlIHRoaXMuZWRnZVBvaW50Q291bnRdO1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMucGFydGljbGVzWyhpICsgMSkgJSB0aGlzLmVkZ2VQb2ludENvdW50XTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGVkZ2UgdmVjdG9ycyBmcm9tIHRoZSBwYXJ0aWNsZSB0byBpdHMgbmVpZ2hib3JzXG4gICAgICBjb25zdCB0b1ByZXYgPSB0ZW1wVmVjLmNvcHkocHJldi5wb3MpLnN1YihwYXJ0aWNsZS5wb3MpO1xuICAgICAgY29uc3QgdG9OZXh0ID0gbmV3IFZlY3RvcjIoKS5jb3B5KG5leHQucG9zKS5zdWIocGFydGljbGUucG9zKTsgLy8gVXNlIGEgc2VwYXJhdGUgVmVjdG9yMiBpbnN0YW5jZVxuXG4gICAgICAvLyBDYWxjdWxhdGUgb3V0d2FyZCBub3JtYWwgdXNpbmcgdGhlIGNyb3NzIHByb2R1Y3QgY29uY2VwdCAoZm9yIDJEKVxuICAgICAgY29uc3QgZWRnZVZlY3RvciA9IHRvTmV4dC5zdWIodG9QcmV2KTsgLy8gVmVjdG9yIGFsb25nIHRoZSBlZGdlIChuZXh0IC0gcHJldilcbiAgICAgIGNvbnN0IG91dHdhcmROb3JtYWwgPSBuZXcgVmVjdG9yMigtZWRnZVZlY3Rvci55LCBlZGdlVmVjdG9yLngpOyAvLyBQZXJwZW5kaWN1bGFyIHZlY3RvclxuXG4gICAgICBpZiAob3V0d2FyZE5vcm1hbC5sZW5ndGhTcSgpIDwgMWUtMTIpIHJldHVybjsgLy8gU2tpcCBpZiBub3JtYWwgaXMgemVybyBsZW5ndGhcblxuICAgICAgb3V0d2FyZE5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgIG91dHdhcmROb3JtYWwubXVsdGlwbHlTY2FsYXIoY2FwcGVkRm9yY2VTaXplKTtcbiAgICAgIHBhcnRpY2xlLmFwcGx5Rm9yY2Uob3V0d2FyZE5vcm1hbCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb2xsaXNpb24gd2l0aCBTdGF0aWMgT2JzdGFjbGVzXG4gIGNvbGxpZGVXaXRoU3RhdGljU2hhcGUoXG4gICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgc2hhcGVUeXBlOiAnbGV0dGVyJyB8IG51bGwsXG4gICAgc2hhcGVQYXJhbXM6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHNpemU6IG51bWJlcjsgbGV0dGVyPzogc3RyaW5nIH0gfCBudWxsXG4gICkge1xuICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZVdpdGhTdGF0aWNTaGFwZSBjYWxsZWRcIik7XG4gICAgaWYgKCFzaGFwZVR5cGUgfHwgIXNoYXBlUGFyYW1zIHx8ICFzaGFwZVBhcmFtcy5sZXR0ZXIpIHJldHVybjtcblxuICAgIC8vIEZvciBsZXR0ZXIgc2hhcGVzXG4gICAgaWYgKHNoYXBlVHlwZSA9PT0gJ2xldHRlcicgJiYgc2hhcGVQYXJhbXMubGV0dGVyKSB7XG4gICAgICBjb25zdCBsZXR0ZXJDZW50ZXJYID0gc2hhcGVQYXJhbXMueCArIHNoYXBlUGFyYW1zLnNpemUgLyAyO1xuICAgICAgY29uc3QgbGV0dGVyQ2VudGVyWSA9IHNoYXBlUGFyYW1zLnkgKyBzaGFwZVBhcmFtcy5zaXplIC8gMjtcbiAgICAgIFxuICAgICAgLy8gQ2FjaGUgbGV0dGVyIGJvdW5kcyBmb3Igb3B0aW1pemF0aW9uXG4gICAgICBjb25zdCBsZXR0ZXJCb3VuZHMgPSB7XG4gICAgICAgIG1pblg6IHNoYXBlUGFyYW1zLngsXG4gICAgICAgIG1pblk6IHNoYXBlUGFyYW1zLnksXG4gICAgICAgIG1heFg6IHNoYXBlUGFyYW1zLnggKyBzaGFwZVBhcmFtcy5zaXplLFxuICAgICAgICBtYXhZOiBzaGFwZVBhcmFtcy55ICsgc2hhcGVQYXJhbXMuc2l6ZSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIENoZWNrIEFMTCBwYXJ0aWNsZXMgZm9yIGNvbGxpc2lvbiB3aXRoIHRoZSBsZXR0ZXIgc2hhcGVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFF1aWNrIGJvdW5kcyBjaGVjayBmaXJzdCAoc2ltcGxlIG9wdGltaXphdGlvbilcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcnRpY2xlLnBvcy54ID49IGxldHRlckJvdW5kcy5taW5YIC0gNSAmJiBcbiAgICAgICAgICBwYXJ0aWNsZS5wb3MueCA8PSBsZXR0ZXJCb3VuZHMubWF4WCArIDUgJiYgXG4gICAgICAgICAgcGFydGljbGUucG9zLnkgPj0gbGV0dGVyQm91bmRzLm1pblkgLSA1ICYmIFxuICAgICAgICAgIHBhcnRpY2xlLnBvcy55IDw9IGxldHRlckJvdW5kcy5tYXhZICsgNVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUZXN0IGlmIHBhcnRpY2xlIGlzIGFjdHVhbGx5IGluc2lkZSB0aGUgbGV0dGVyIHNoYXBlXG4gICAgICAgICAgY29uc3QgaXNJbnNpZGUgPSBpc1BvaW50SW5MZXR0ZXIoXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBzaGFwZVBhcmFtcy5sZXR0ZXIsXG4gICAgICAgICAgICBsZXR0ZXJDZW50ZXJYLFxuICAgICAgICAgICAgbGV0dGVyQ2VudGVyWSxcbiAgICAgICAgICAgIHNoYXBlUGFyYW1zLnNpemUsXG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3MueCxcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvcy55XG4gICAgICAgICAgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXNJbnNpZGUpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgbGV0dGVyIHRvIHBhcnRpY2xlXG4gICAgICAgICAgICBjb25zdCB0b1BhcnRpY2xlID0gbmV3IFZlY3RvcjIoXG4gICAgICAgICAgICAgIHBhcnRpY2xlLnBvcy54IC0gbGV0dGVyQ2VudGVyWCxcbiAgICAgICAgICAgICAgcGFydGljbGUucG9zLnkgLSBsZXR0ZXJDZW50ZXJZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiB2ZWN0b3IgaXMgbmVhciB6ZXJvLCB1c2UgYSByYW5kb20gZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiAodG9QYXJ0aWNsZS5sZW5ndGhTcSgpIDwgMC4xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJhbmRvbUFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICB0b1BhcnRpY2xlLnNldChNYXRoLmNvcyhyYW5kb21BbmdsZSksIE1hdGguc2luKHJhbmRvbUFuZ2xlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBcbiAgICAgICAgICAgIHRvUGFydGljbGUubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyB3aXRoaW4gYW4gZW5jbG9zZWQgc3BhY2VcbiAgICAgICAgICAgIGNvbnN0IGlzRW5jbG9zZWQgPSAoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByYXlDb3VudCA9IDMyO1xuICAgICAgICAgICAgICBjb25zdCByYXlMZW5ndGggPSBzaGFwZVBhcmFtcy5zaXplICogMC43NTtcbiAgICAgICAgICAgICAgbGV0IGludGVyc2VjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHJheUNvdW50KSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJheVggPSBwYXJ0aWNsZS5wb3MueCArIE1hdGguY29zKGFuZ2xlKSAqIHJheUxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByYXlZID0gcGFydGljbGUucG9zLnkgKyBNYXRoLnNpbihhbmdsZSkgKiByYXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGlzUG9pbnRJbkxldHRlcihjdHgsIHNoYXBlUGFyYW1zLmxldHRlciEsIGxldHRlckNlbnRlclgsIGxldHRlckNlbnRlclksIHNoYXBlUGFyYW1zLnNpemUsIHJheVgsIHJheVkpKSB7XG4gICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uQ291bnQgLyByYXlDb3VudCA+PSAwLjc1O1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgLy8gTW9kaWZ5IHJlcHVsc2lvbiBkaXJlY3Rpb24gaWYgd2l0aGluIGFuIGVuY2xvc2VkIHNwYWNlXG4gICAgICAgICAgICBpZiAoaXNFbmNsb3NlZCkge1xuICAgICAgICAgICAgICAvLyBJbnZlcnQgdGhlIGRpcmVjdGlvbiB0byBndWlkZSB0aGUgcGFydGljbGUgaW53YXJkc1xuICAgICAgICAgICAgICB0b1BhcnRpY2xlLm11bHRpcGx5U2NhbGFyKC0xKTtcblxuICAgICAgICAgICAgICAvLyBVc2UgYSBzdHJvbmcgcHVzaCBmb3JjZVxuICAgICAgICAgICAgICBjb25zdCBwdXNoRm9yY2UgPSA1LjA7XG4gICAgICAgICAgICAgIHRvUGFydGljbGUubXVsdGlwbHlTY2FsYXIocHVzaEZvcmNlKTtcblxuICAgICAgICAgICAgICAvLyBBcHBseSB0aGlzIHN0cm9uZyBmb3JjZSB0byBpbW1lZGlhdGVseSBwdXNoIHRoZSBwYXJ0aWNsZSBcbiAgICAgICAgICAgICAgcGFydGljbGUuYXBwbHlGb3JjZSh0b1BhcnRpY2xlKTtcblxuICAgICAgICAgICAgICAvLyBBbHNvIGRpcmVjdGx5IG1vZGlmeSB2ZWxvY2l0eSB0byBlbnN1cmUgaW1tZWRpYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICAgIGNvbnN0IGVzY2FwZVZlbG9jaXR5ID0gdG9QYXJ0aWNsZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG4gICAgICAgICAgICAgIHBhcnRpY2xlLnZlbC5hZGQoZXNjYXBlVmVsb2NpdHkpO1xuXG4gICAgICAgICAgICAgIC8vIEFwcGx5IHN0cm9uZyBkYW1waW5nIHRvIG90aGVyIGRpcmVjdGlvbnMgdG8gcHJldmVudCBvc2NpbGxhdGlvblxuICAgICAgICAgICAgICBjb25zdCBkYW1waW5nRmFjdG9yID0gMC41O1xuICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWwubXVsdGlwbHlTY2FsYXIoZGFtcGluZ0ZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbnNpZGUsIHJlc2V0IHN0dWNrIGNvdW50ZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAocGFydGljbGUuc3R1Y2tGcmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJ0aWNsZS5zdHVja0ZyYW1lcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZmlsbENvbG9yOiBzdHJpbmcsIHN0cm9rZUNvbG9yOiBzdHJpbmcsIHN0YXRpY1NoYXBlVHlwZTogJ2xldHRlcicgfCBudWxsLCBzdGF0aWNTaGFwZVBhcmFtczogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgc2l6ZTogbnVtYmVyOyBsZXR0ZXI/OiBzdHJpbmcgfSB8IG51bGwpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIC8vIEVuc3VyZSBmaXJzdCBwYXJ0aWNsZSBleGlzdHMgYmVmb3JlIG1vdmluZyB0byBpdFxuICAgIGlmICghdGhpcy5wYXJ0aWNsZXNbMF0/LnBvcykge1xuICAgICAgY29uc29sZS53YXJuKFwiRmlyc3QgcGFydGljbGUgbWlzc2luZyBpbiBkcmF3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHgubW92ZVRvKHRoaXMucGFydGljbGVzWzBdLnBvcy54LCB0aGlzLnBhcnRpY2xlc1swXS5wb3MueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGkgJSB0aGlzLmVkZ2VQb2ludENvdW50O1xuICAgICAgaWYgKHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0/LnBvcykge1xuICAgICAgICBjdHgubGluZVRvKHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0ucG9zLngsIHRoaXMucGFydGljbGVzW2N1cnJlbnRJbmRleF0ucG9zLnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJ0aWNsZSBvciBwb3NpdGlvbiB1bmRlZmluZWQgYXQgaW5kZXggJHtjdXJyZW50SW5kZXh9IGR1cmluZyBkcmF3YCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTsgLy8gQ2xvc2UgcGF0aCBhZnRlciBsb29wXG5cbiAgICAvLyBDaGVjayBjb250ZXh0IHN0YXRlIGJlZm9yZSBmaWxsaW5nL3N0cm9raW5nXG4gICAgaWYgKGN0eC5maWxsU3R5bGUgIT09IGZpbGxDb2xvcikgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSBzdHJva2VDb2xvcikgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyBHZXQgU1ZHIHBhdGggZGF0YSBmb3IgdGhpcyBibG9iXG4gIGdldFNWR1BhdGgoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNsZXMubGVuZ3RoIDwgMikgcmV0dXJuIFwiXCI7XG5cbiAgICBsZXQgcGF0aCA9IGBNICR7dGhpcy5wYXJ0aWNsZXNbMF0ucG9zLngudG9GaXhlZCgyKX0gJHt0aGlzLnBhcnRpY2xlc1swXS5wb3MueS50b0ZpeGVkKDIpfWA7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmVkZ2VQb2ludENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaSAlIHRoaXMuZWRnZVBvaW50Q291bnRdO1xuICAgICAgaWYgKHBhcnRpY2xlPy5wb3MpIHtcbiAgICAgICAgcGF0aCArPSBgIEwgJHtwYXJ0aWNsZS5wb3MueC50b0ZpeGVkKDIpfSAke3BhcnRpY2xlLnBvcy55LnRvRml4ZWQoMil9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFydGljbGUgb3IgcG9zaXRpb24gdW5kZWZpbmVkIGF0IGluZGV4ICR7aSAlIHRoaXMuZWRnZVBvaW50Q291bnR9IGR1cmluZyBTVkcgcGF0aCBnZW5lcmF0aW9uYCk7XG4gICAgICAgIHJldHVybiBwYXRoICsgXCIgWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGggKz0gXCIgWlwiO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgdXBkYXRlKFxuICAgIGJsb2JzOiBCbG9iW10sXG4gICAgc3ByaW5nVGVuc2lvbjogbnVtYmVyLFxuICAgIGNhbnZhc1dpZHRoOiBudW1iZXIsXG4gICAgY2FudmFzSGVpZ2h0OiBudW1iZXIsXG4gICAgbWFyZ2luOiBudW1iZXIsXG4gICAgaXNSb3VuZGVkQ29udGFpbmVyOiBib29sZWFuLFxuICAgIGludGVyYWN0aW9uU3RyZW5ndGg6IG51bWJlcixcbiAgICBtYXhFeHBhbnNpb25GYWN0b3I6IG51bWJlcixcbiAgICBncmF2aXR5OiBudW1iZXIsXG4gICAgZGFtcGluZzogbnVtYmVyLFxuICAgIHN0YXRpY1NoYXBlVHlwZTogJ2xldHRlcicgfCBudWxsLFxuICAgIHN0YXRpY1NoYXBlUGFyYW1zOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBzaXplOiBudW1iZXI7IGxldHRlcj86IHN0cmluZyB9IHwgbnVsbCxcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGxcbiAgKSB7XG4gICAgLy8gLS0tIEZvcmNlIEFwcGxpY2F0aW9uIFBoYXNlIC0tLVxuICAgIC8vIEFwcGx5IGludGVybmFsIGZvcmNlcyBmaXJzdCAocHJlc3N1cmUsIHNwcmluZ3MpXG4gICAgdGhpcy5tYWludGFpblByZXNzdXJlKCk7XG4gICAgdGhpcy5zcHJpbmdzLmZvckVhY2goKHNwcmluZykgPT4gc3ByaW5nLnVwZGF0ZShzcHJpbmdUZW5zaW9uKSk7XG5cbiAgICAvLyBBcHBseSBleHRlcm5hbCBmb3JjZXMgKGdyYXZpdHksIGludGVyLWJsb2IgcmVwdWxzaW9uLCBzdGF0aWMgY29sbGlzaW9uKVxuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlKSA9PiB7XG4gICAgICBwYXJ0aWNsZS5hcHBseUZvcmNlKG5ldyBWZWN0b3IyKDAsIGdyYXZpdHkgKiAwLjEpKTsgLy8gQXBwbHkgZ3Jhdml0eSBwZXIgcGFydGljbGVcbiAgICB9KTtcbiAgICB0aGlzLnJlcGVsQmxvYnMoYmxvYnMsIGludGVyYWN0aW9uU3RyZW5ndGgpO1xuICAgIGlmIChjdHggJiYgc3RhdGljU2hhcGVUeXBlICYmIHN0YXRpY1NoYXBlUGFyYW1zKSB7XG4gICAgICB0aGlzLmNvbGxpZGVXaXRoU3RhdGljU2hhcGUoY3R4LCBzdGF0aWNTaGFwZVR5cGUsIHN0YXRpY1NoYXBlUGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gW0RFQlVHXSBEcmF3IHJheXMgZm9yIGVuY2xvc2VkIHNwYWNlIGNoZWNrIC0tLVxuICAgIGlmIChjdHggJiYgc3RhdGljU2hhcGVUeXBlID09PSAnbGV0dGVyJyAmJiBzdGF0aWNTaGFwZVBhcmFtcyAmJiBzdGF0aWNTaGFwZVBhcmFtcy5sZXR0ZXIpIHtcbiAgICAgIGNvbnN0IGxldHRlckNlbnRlclggPSBzdGF0aWNTaGFwZVBhcmFtcy54ICsgc3RhdGljU2hhcGVQYXJhbXMuc2l6ZSAvIDI7XG4gICAgICBjb25zdCBsZXR0ZXJDZW50ZXJZID0gc3RhdGljU2hhcGVQYXJhbXMueSArIHN0YXRpY1NoYXBlUGFyYW1zLnNpemUgLyAyO1xuICAgICAgY29uc3QgeyBzaXplLCBsZXR0ZXIgfSA9IHN0YXRpY1NoYXBlUGFyYW1zO1xuICAgICAgY29uc3QgcmF5Q291bnQgPSAxNjtcbiAgICAgIGNvbnN0IHJheUxlbmd0aCA9IHNpemUgKiAwLjU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJheUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHJheUNvdW50KSAqIE1hdGguUEkgKiAyO1xuICAgICAgICBjb25zdCByYXlYID0gdGhpcy5jZW50cmUueCArIE1hdGguY29zKGFuZ2xlKSAqIHJheUxlbmd0aDtcbiAgICAgICAgY29uc3QgcmF5WSA9IHRoaXMuY2VudHJlLnkgKyBNYXRoLnNpbihhbmdsZSkgKiByYXlMZW5ndGg7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMuY2VudHJlLngsIHRoaXMuY2VudHJlLnkpO1xuICAgICAgICBjdHgubGluZVRvKHJheVgsIHJheVkpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0gW0RFQlVHXSBFbmQgZHJhdyByYXlzIGZvciBlbmNsb3NlZCBzcGFjZSBjaGVjayAtLS1cblxuICAgIC8vIC0tLSBVcGRhdGUgUGhhc2UgLS0tXG4gICAgLy8gVXBkYXRlIHBhcnRpY2xlcyB1c2luZyBhcHBsaWVkIGZvcmNlcyBhbmQgZGFtcGluZ1xuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlKSA9PiB7XG4gICAgICBwYXJ0aWNsZS51cGRhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgbWFyZ2luLCBpc1JvdW5kZWRDb250YWluZXIsIGRhbXBpbmcpO1xuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGJsb2Igc3RhdGUgYmFzZWQgb24gbmV3IHBhcnRpY2xlIHBvc2l0aW9uc1xuICAgIHRoaXMudXBkYXRlQ2VudHJlKCk7XG4gICAgdGhpcy51cGRhdGVNYXhSYWRpdXMoKTtcblxuICAgIC8vIEFwcGx5IGdyb3d0aCBhZnRlciB1cGRhdGVzXG4gICAgdGhpcy5ncm93KG1heEV4cGFuc2lvbkZhY3Rvcik7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMiIsIlBhcnRpY2xlIiwiU3ByaW5nIiwiaXNQb2ludEluTGV0dGVyIiwidGVtcFZlYyIsIkJsb2IiLCJzZXR1cCIsInBhcnRpY2xlcyIsImxlbmd0aCIsInNwcmluZ3MiLCJzYWZlUmFkaXVzIiwibWF4UmFkaXVzIiwiYW5nbGVTdGVwIiwiTWF0aCIsIlBJIiwiZWRnZVBvaW50Q291bnQiLCJpbml0aWFsU3ByaW5nTGVuZ3RoIiwibWF4Iiwic2luIiwiaSIsImFuZ2xlIiwieCIsImNvcyIsImNlbnRyZSIsInkiLCJwdXNoIiwidXBkYXRlQ2VudHJlIiwic2V0IiwiZm9yRWFjaCIsInAiLCJhZGQiLCJwb3MiLCJkaXZpZGVTY2FsYXIiLCJ1cGRhdGVNYXhSYWRpdXMiLCJtYXhEaXN0U3EiLCJwYXJ0aWNsZSIsImRpc3RTcSIsImRpc3RhbmNlVG9TcXVhcmVkIiwic3FydCIsInJlcGVsQmxvYnMiLCJibG9icyIsImludGVyYWN0aW9uU3RyZW5ndGgiLCJibG9iQiIsImlkIiwiZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSIsInJlcGVsRGlzdGFuY2UiLCJkaXN0QmV0d2VlbkNlbnRlcnNTcSIsImNvbWJpbmVkUmFkaWkiLCJpbnRlcmFjdGlvblJhbmdlU3EiLCJwb3ciLCJwYXJ0aWNsZUEiLCJwYXJ0aWNsZUIiLCJjb3B5Iiwic3ViIiwibGVuZ3RoU3EiLCJyZXBlbERpc3RTcSIsImRpc3QiLCJvdmVybGFwIiwiZm9yY2VNYWduaXR1ZGUiLCJtaW4iLCJtYXhSZXB1bHNpb25Gb3JjZSIsIm11bHRpcGx5U2NhbGFyIiwiYXBwbHlGb3JjZSIsImFyZWEiLCJ0b3RhbCIsInAxIiwicDIiLCJhYnMiLCJncm93IiwibWF4RXhwYW5zaW9uRmFjdG9yIiwiaW5pdGlhbEFyZWEiLCJtYXhUYXJnZXRBcmVhIiwidGFyZ2V0QXJlYSIsIm1haW50YWluUHJlc3N1cmUiLCJjdXJyZW50QXJlYSIsImFyZWFSYXRpbyIsImNsYW1wZWRSYXRpbyIsInByZXNzdXJlRGlmZmVyZW5jZSIsImZvcmNlU2l6ZSIsInByZXNzdXJlQ29uc3RhbnQiLCJtYXhQcmVzc3VyZUZvcmNlIiwiY2FwcGVkRm9yY2VTaXplIiwicHJldiIsIm5leHQiLCJ0b1ByZXYiLCJ0b05leHQiLCJlZGdlVmVjdG9yIiwib3V0d2FyZE5vcm1hbCIsIm5vcm1hbGl6ZSIsImNvbGxpZGVXaXRoU3RhdGljU2hhcGUiLCJjdHgiLCJzaGFwZVR5cGUiLCJzaGFwZVBhcmFtcyIsImNvbnNvbGUiLCJsb2ciLCJsZXR0ZXIiLCJsZXR0ZXJDZW50ZXJYIiwic2l6ZSIsImxldHRlckNlbnRlclkiLCJsZXR0ZXJCb3VuZHMiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiaXNJbnNpZGUiLCJ0b1BhcnRpY2xlIiwicmFuZG9tQW5nbGUiLCJyYW5kb20iLCJpc0VuY2xvc2VkIiwicmF5Q291bnQiLCJyYXlMZW5ndGgiLCJpbnRlcnNlY3Rpb25Db3VudCIsInJheVgiLCJyYXlZIiwicHVzaEZvcmNlIiwiZXNjYXBlVmVsb2NpdHkiLCJjbG9uZSIsInZlbCIsImRhbXBpbmdGYWN0b3IiLCJzdHVja0ZyYW1lcyIsInVuZGVmaW5lZCIsImRyYXciLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsInN0YXRpY1NoYXBlVHlwZSIsInN0YXRpY1NoYXBlUGFyYW1zIiwiYmVnaW5QYXRoIiwid2FybiIsIm1vdmVUbyIsImN1cnJlbnRJbmRleCIsImxpbmVUbyIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiZmlsbCIsInN0cm9rZSIsImdldFNWR1BhdGgiLCJwYXRoIiwidG9GaXhlZCIsInVwZGF0ZSIsInNwcmluZ1RlbnNpb24iLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsIm1hcmdpbiIsImlzUm91bmRlZENvbnRhaW5lciIsImdyYXZpdHkiLCJkYW1waW5nIiwic3ByaW5nIiwiY29uc3RydWN0b3IiLCJzdGFydFNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/blob-simulation/blob.ts\n"));

/***/ })

});