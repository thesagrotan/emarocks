"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Blob.ts":
/*!****************************!*\
  !*** ./components/Blob.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n\nclass Blob {\n    update(blobs, springTension, canvasWidth, canvasHeight, margin, isRoundedContainer) {\n        const now = Date.now();\n        if (now - this.lastUpdateLogTime > this.logThrottleInterval) {\n            console.log(\"Updating blob\", this);\n            this.lastUpdateLogTime = now;\n        }\n        // Apply velocity to position\n        this.position.add(this.velocity);\n        // Apply damping to velocity\n        this.velocity.multiplyScalar(0.98); // Example damping factor\n        // Keep the blob within canvas bounds\n        const radius = this.size;\n        if (this.position.x - radius < margin || this.position.x + radius > canvasWidth - margin) {\n            this.velocity.x *= -1; // Reverse velocity on X-axis\n            this.position.x = Math.max(margin + radius, Math.min(this.position.x, canvasWidth - margin - radius));\n        }\n        if (this.position.y - radius < margin || this.position.y + radius > canvasHeight - margin) {\n            this.velocity.y *= -1; // Reverse velocity on Y-axis\n            this.position.y = Math.max(margin + radius, Math.min(this.position.y, canvasHeight - margin - radius));\n        }\n        // Interact with other blobs (simple repulsion)\n        blobs.forEach((otherBlob)=>{\n            if (otherBlob === this) return;\n            const distance = this.position.distanceTo(otherBlob.position);\n            const minDistance = this.size + otherBlob.size;\n            if (distance < minDistance) {\n                const overlap = minDistance - distance;\n                const direction = this.position.clone().sub(otherBlob.position).normalize();\n                this.position.add(direction.multiplyScalar(overlap / 2));\n                otherBlob.position.sub(direction.multiplyScalar(overlap / 2));\n            }\n        });\n    }\n    draw(ctx, fillColor, borderColor) {\n        const now = Date.now();\n        if (now - this.lastDrawLogTime > this.logThrottleInterval) {\n            console.log(\"Drawing blob\", this);\n            this.lastDrawLogTime = now;\n        }\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\n        ctx.fillStyle = fillColor;\n        ctx.fill();\n        ctx.strokeStyle = borderColor;\n        ctx.stroke();\n        ctx.closePath();\n    }\n    getSVGPath() {\n        return \"M\".concat(this.position.x, \",\").concat(this.position.y, \" A\").concat(this.size, \",\").concat(this.size, \" 0 1,0 \").concat(this.position.x + 0.1, \",\").concat(this.position.y);\n    }\n    constructor(x, y, size, repelDistance){\n        // Reduce logging frequency in the `update` and `draw` methods\n        this.lastUpdateLogTime = 0;\n        this.lastDrawLogTime = 0;\n        this.logThrottleInterval = 100 // Log every 100ms\n        ;\n        this.position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\n        this.velocity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);\n        this.size = size;\n        this.type = \"circle\";\n        this.repelDistance = repelDistance;\n        this.centre = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\n        this.targetArea = Math.PI * size * size;\n        this.maxRadius = size;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQmxvYi50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQUV6QixNQUFNQztJQTBCWEMsT0FBT0MsS0FBYSxFQUFFQyxhQUFxQixFQUFFQyxXQUFtQixFQUFFQyxZQUFvQixFQUFFQyxNQUFjLEVBQUVDLGtCQUEyQixFQUFFO1FBQ25JLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsSUFBSUEsTUFBTSxJQUFJLENBQUNFLGlCQUFpQixHQUFHLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUU7WUFDM0RDLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUIsSUFBSTtZQUNqQyxJQUFJLENBQUNILGlCQUFpQixHQUFHRjtRQUMzQjtRQUVBLDZCQUE2QjtRQUM3QixJQUFJLENBQUNNLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsUUFBUTtRQUUvQiw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDQSxRQUFRLENBQUNDLGNBQWMsQ0FBQyxPQUFPLHlCQUF5QjtRQUU3RCxxQ0FBcUM7UUFDckMsTUFBTUMsU0FBUyxJQUFJLENBQUNDLElBQUk7UUFDeEIsSUFBSSxJQUFJLENBQUNMLFFBQVEsQ0FBQ00sQ0FBQyxHQUFHRixTQUFTWixVQUFVLElBQUksQ0FBQ1EsUUFBUSxDQUFDTSxDQUFDLEdBQUdGLFNBQVNkLGNBQWNFLFFBQVE7WUFDeEYsSUFBSSxDQUFDVSxRQUFRLENBQUNJLENBQUMsSUFBSSxDQUFDLEdBQUcsNkJBQTZCO1lBQ3BELElBQUksQ0FBQ04sUUFBUSxDQUFDTSxDQUFDLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQ2hCLFNBQVNZLFFBQVFHLEtBQUtFLEdBQUcsQ0FBQyxJQUFJLENBQUNULFFBQVEsQ0FBQ00sQ0FBQyxFQUFFaEIsY0FBY0UsU0FBU1k7UUFDL0Y7UUFDQSxJQUFJLElBQUksQ0FBQ0osUUFBUSxDQUFDVSxDQUFDLEdBQUdOLFNBQVNaLFVBQVUsSUFBSSxDQUFDUSxRQUFRLENBQUNVLENBQUMsR0FB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R2hDLEtBQUtxQixFQUFFLEdBQUd2QixPQUFPQTtRQUNuQyxJQUFJLENBQUNtQyxTQUFTLEdBQUduQztJQUNuQjtBQWtFRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhbmllbC9EZXZlbG9wZXIvZW1hcm9ja3MvY29tcG9uZW50cy9CbG9iLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcblxuZXhwb3J0IGNsYXNzIEJsb2Ige1xuICBwb3NpdGlvbjogVmVjdG9yMjtcbiAgdmVsb2NpdHk6IFZlY3RvcjI7XG4gIHNpemU6IG51bWJlcjtcbiAgdHlwZTogc3RyaW5nO1xuICByZXBlbERpc3RhbmNlOiBudW1iZXI7XG4gIGNlbnRyZTogVmVjdG9yMjtcbiAgdGFyZ2V0QXJlYTogbnVtYmVyO1xuICBtYXhSYWRpdXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCByZXBlbERpc3RhbmNlOiBudW1iZXIpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IyKDAsIDApO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy50eXBlID0gXCJjaXJjbGVcIjtcbiAgICB0aGlzLnJlcGVsRGlzdGFuY2UgPSByZXBlbERpc3RhbmNlO1xuICAgIHRoaXMuY2VudHJlID0gbmV3IFZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy50YXJnZXRBcmVhID0gTWF0aC5QSSAqIHNpemUgKiBzaXplO1xuICAgIHRoaXMubWF4UmFkaXVzID0gc2l6ZTtcbiAgfVxuXG4gIC8vIFJlZHVjZSBsb2dnaW5nIGZyZXF1ZW5jeSBpbiB0aGUgYHVwZGF0ZWAgYW5kIGBkcmF3YCBtZXRob2RzXG4gIHByaXZhdGUgbGFzdFVwZGF0ZUxvZ1RpbWUgPSAwO1xuICBwcml2YXRlIGxhc3REcmF3TG9nVGltZSA9IDA7XG4gIHByaXZhdGUgbG9nVGhyb3R0bGVJbnRlcnZhbCA9IDEwMDsgLy8gTG9nIGV2ZXJ5IDEwMG1zXG5cbiAgdXBkYXRlKGJsb2JzOiBCbG9iW10sIHNwcmluZ1RlbnNpb246IG51bWJlciwgY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIsIG1hcmdpbjogbnVtYmVyLCBpc1JvdW5kZWRDb250YWluZXI6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSB0aGlzLmxhc3RVcGRhdGVMb2dUaW1lID4gdGhpcy5sb2dUaHJvdHRsZUludGVydmFsKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIGJsb2JcIiwgdGhpcyk7XG4gICAgICB0aGlzLmxhc3RVcGRhdGVMb2dUaW1lID0gbm93O1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHZlbG9jaXR5IHRvIHBvc2l0aW9uXG4gICAgdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eSk7XG5cbiAgICAvLyBBcHBseSBkYW1waW5nIHRvIHZlbG9jaXR5XG4gICAgdGhpcy52ZWxvY2l0eS5tdWx0aXBseVNjYWxhcigwLjk4KTsgLy8gRXhhbXBsZSBkYW1waW5nIGZhY3RvclxuXG4gICAgLy8gS2VlcCB0aGUgYmxvYiB3aXRoaW4gY2FudmFzIGJvdW5kc1xuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuc2l6ZTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbi54IC0gcmFkaXVzIDwgbWFyZ2luIHx8IHRoaXMucG9zaXRpb24ueCArIHJhZGl1cyA+IGNhbnZhc1dpZHRoIC0gbWFyZ2luKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnggKj0gLTE7IC8vIFJldmVyc2UgdmVsb2NpdHkgb24gWC1heGlzXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBNYXRoLm1heChtYXJnaW4gKyByYWRpdXMsIE1hdGgubWluKHRoaXMucG9zaXRpb24ueCwgY2FudmFzV2lkdGggLSBtYXJnaW4gLSByYWRpdXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9zaXRpb24ueSAtIHJhZGl1cyA8IG1hcmdpbiB8fCB0aGlzLnBvc2l0aW9uLnkgKyByYWRpdXMgPiBjYW52YXNIZWlnaHQgLSBtYXJnaW4pIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSAqPSAtMTsgLy8gUmV2ZXJzZSB2ZWxvY2l0eSBvbiBZLWF4aXNcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IE1hdGgubWF4KG1hcmdpbiArIHJhZGl1cywgTWF0aC5taW4odGhpcy5wb3NpdGlvbi55LCBjYW52YXNIZWlnaHQgLSBtYXJnaW4gLSByYWRpdXMpKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmFjdCB3aXRoIG90aGVyIGJsb2JzIChzaW1wbGUgcmVwdWxzaW9uKVxuICAgIGJsb2JzLmZvckVhY2goKG90aGVyQmxvYikgPT4ge1xuICAgICAgaWYgKG90aGVyQmxvYiA9PT0gdGhpcykgcmV0dXJuO1xuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucG9zaXRpb24uZGlzdGFuY2VUbyhvdGhlckJsb2IucG9zaXRpb24pO1xuICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSB0aGlzLnNpemUgKyBvdGhlckJsb2Iuc2l6ZTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IG1pbkRpc3RhbmNlIC0gZGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5zdWIob3RoZXJCbG9iLnBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKG92ZXJsYXAgLyAyKSk7XG4gICAgICAgIG90aGVyQmxvYi5wb3NpdGlvbi5zdWIoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKG92ZXJsYXAgLyAyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBmaWxsQ29sb3I6IHN0cmluZywgYm9yZGVyQ29sb3I6IHN0cmluZykge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKG5vdyAtIHRoaXMubGFzdERyYXdMb2dUaW1lID4gdGhpcy5sb2dUaHJvdHRsZUludGVydmFsKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkRyYXdpbmcgYmxvYlwiLCB0aGlzKTtcbiAgICAgIHRoaXMubGFzdERyYXdMb2dUaW1lID0gbm93O1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCB0aGlzLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGdldFNWR1BhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYE0ke3RoaXMucG9zaXRpb24ueH0sJHt0aGlzLnBvc2l0aW9uLnl9IEEke3RoaXMuc2l6ZX0sJHt0aGlzLnNpemV9IDAgMSwwICR7dGhpcy5wb3NpdGlvbi54ICsgMC4xfSwke3RoaXMucG9zaXRpb24ueX1gO1xuICB9XG59Il0sIm5hbWVzIjpbIlZlY3RvcjIiLCJCbG9iIiwidXBkYXRlIiwiYmxvYnMiLCJzcHJpbmdUZW5zaW9uIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJtYXJnaW4iLCJpc1JvdW5kZWRDb250YWluZXIiLCJub3ciLCJEYXRlIiwibGFzdFVwZGF0ZUxvZ1RpbWUiLCJsb2dUaHJvdHRsZUludGVydmFsIiwiY29uc29sZSIsImxvZyIsInBvc2l0aW9uIiwiYWRkIiwidmVsb2NpdHkiLCJtdWx0aXBseVNjYWxhciIsInJhZGl1cyIsInNpemUiLCJ4IiwiTWF0aCIsIm1heCIsIm1pbiIsInkiLCJmb3JFYWNoIiwib3RoZXJCbG9iIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwibWluRGlzdGFuY2UiLCJvdmVybGFwIiwiZGlyZWN0aW9uIiwiY2xvbmUiLCJzdWIiLCJub3JtYWxpemUiLCJkcmF3IiwiY3R4IiwiZmlsbENvbG9yIiwiYm9yZGVyQ29sb3IiLCJsYXN0RHJhd0xvZ1RpbWUiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsImZpbGwiLCJzdHJva2VTdHlsZSIsInN0cm9rZSIsImNsb3NlUGF0aCIsImdldFNWR1BhdGgiLCJjb25zdHJ1Y3RvciIsInJlcGVsRGlzdGFuY2UiLCJ0eXBlIiwiY2VudHJlIiwidGFyZ2V0QXJlYSIsIm1heFJhZGl1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Blob.ts\n"));

/***/ })

});