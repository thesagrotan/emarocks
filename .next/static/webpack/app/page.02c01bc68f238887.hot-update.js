"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/blob-simulation/blob.ts":
/*!********************************************!*\
  !*** ./components/blob-simulation/blob.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./particle */ \"(app-pages-browser)/./components/blob-simulation/particle.ts\");\n/* harmony import */ var _spring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spring */ \"(app-pages-browser)/./components/blob-simulation/spring.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./components/blob-simulation/utils.ts\");\n\n\n\n // Import the isPointInLetter function\n// Temporary vector for calculations\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2();\n// Blob Class - represents a complete blob with particles and springs\nclass Blob {\n    setup() {\n        this.particles.length = 0;\n        this.springs.length = 0;\n        const safeRadius = this.maxRadius; // Already ensured > 0 in constructor\n        const angleStep = Math.PI * 2 / this.edgePointCount;\n        // Ensure initialSpringLength is positive and reasonable\n        const initialSpringLength = Math.max(1e-6, safeRadius * Math.sin(Math.PI / this.edgePointCount) * 2);\n        for(let i = 0; i < this.edgePointCount; i++){\n            const angle = i * angleStep;\n            const x = Math.cos(angle) * safeRadius + this.centre.x;\n            const y = Math.sin(angle) * safeRadius + this.centre.y;\n            this.particles.push(new _particle__WEBPACK_IMPORTED_MODULE_0__.Particle(x, y));\n            if (i > 0) {\n                this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[i], this.particles[i - 1], initialSpringLength));\n            }\n        }\n        this.springs.push(new _spring__WEBPACK_IMPORTED_MODULE_1__.Spring(this.particles[0], this.particles[this.edgePointCount - 1], initialSpringLength));\n    }\n    updateCentre() {\n        if (this.particles.length === 0) return;\n        this.centre.set(0, 0);\n        this.particles.forEach((p)=>this.centre.add(p.pos));\n        this.centre.divideScalar(this.particles.length);\n    }\n    updateMaxRadius() {\n        if (this.particles.length === 0) {\n            this.maxRadius = 0;\n            return;\n        }\n        let maxDistSq = 0;\n        this.particles.forEach((particle)=>{\n            const distSq = this.centre.distanceToSquared(particle.pos);\n            if (distSq > maxDistSq) maxDistSq = distSq;\n        });\n        this.maxRadius = Math.sqrt(maxDistSq);\n    }\n    // Repel other blobs\n    repelBlobs(blobs, interactionStrength) {\n        blobs.forEach((blobB)=>{\n            if (this.id === blobB.id) return;\n            // Use the same repelDistance for both blobs to ensure consistency\n            const effectiveRepelDistance = Math.max(this.repelDistance, blobB.repelDistance);\n            const distBetweenCentersSq = this.centre.distanceToSquared(blobB.centre);\n            // Use radii squared for comparison to avoid sqrt\n            const combinedRadii = this.maxRadius + blobB.maxRadius;\n            const interactionRangeSq = Math.pow(combinedRadii + effectiveRepelDistance, 2);\n            // Optimization: Broad phase check based on centers and radii + repel distance\n            if (distBetweenCentersSq > interactionRangeSq) return;\n            // Narrow phase: Check particle pairs\n            this.particles.forEach((particleA)=>{\n                blobB.particles.forEach((particleB)=>{\n                    tempVec.copy(particleA.pos).sub(particleB.pos);\n                    const distSq = tempVec.lengthSq(); // Use squared distance\n                    // Apply repulsion force if within repelDistance squared\n                    const repelDistSq = effectiveRepelDistance * effectiveRepelDistance;\n                    if (distSq > 1e-12 && distSq < repelDistSq) {\n                        const dist = Math.sqrt(distSq);\n                        const overlap = effectiveRepelDistance - dist;\n                        // Calculate force magnitude based on overlap and strength\n                        let forceMagnitude = overlap * interactionStrength;\n                        // Cap the force magnitude\n                        forceMagnitude = Math.min(forceMagnitude, this.maxRepulsionForce);\n                        // Normalize direction vector (reuse tempVec) and apply magnitude\n                        tempVec.multiplyScalar(forceMagnitude / dist);\n                        // Apply forces ensuring they are finite\n                        particleA.applyForce(tempVec);\n                        particleB.applyForce(tempVec.multiplyScalar(-1)); // Apply opposite force\n                    }\n                });\n            });\n        });\n    }\n    get area() {\n        let total = 0;\n        if (this.particles.length < 3) return 0;\n        for(let i = 0; i < this.edgePointCount; i++){\n            const p1 = this.particles[i].pos;\n            const p2 = this.particles[(i + 1) % this.edgePointCount].pos;\n            total += p1.x * p2.y - p2.x * p1.y;\n        }\n        return Math.abs(total / 2);\n    }\n    grow(maxExpansionFactor) {\n        if (this.initialArea <= 0) return;\n        const maxTargetArea = this.initialArea * Math.max(1, maxExpansionFactor);\n        if (this.targetArea < maxTargetArea) {\n            this.targetArea *= 1.005; // Slow growth\n            this.targetArea = Math.min(this.targetArea, maxTargetArea); // Clamp to max\n        } else if (this.targetArea > maxTargetArea) {\n            this.targetArea = maxTargetArea;\n        }\n    }\n    maintainPressure() {\n        const currentArea = this.area;\n        if (currentArea < 1e-6 || this.targetArea < 1e-6) return;\n        // Make pressure force proportional to the difference ratio, but prevent extreme forces\n        const areaRatio = this.targetArea / currentArea;\n        // Clamp the ratio to prevent excessive forces when area is very small\n        const clampedRatio = Math.max(0.5, Math.min(areaRatio, 2.0));\n        const pressureDifference = clampedRatio - 1;\n        const forceSize = pressureDifference * this.pressureConstant;\n        // Limit the maximum force size to prevent instability\n        const maxPressureForce = 0.1; // Example cap\n        const cappedForceSize = Math.max(-maxPressureForce, Math.min(forceSize, maxPressureForce));\n        this.particles.forEach((particle, i)=>{\n            const prev = this.particles[(i + this.edgePointCount - 1) % this.edgePointCount];\n            const next = this.particles[(i + 1) % this.edgePointCount];\n            // Calculate edge vectors from the particle to its neighbors\n            const toPrev = tempVec.copy(prev.pos).sub(particle.pos);\n            const toNext = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2().copy(next.pos).sub(particle.pos); // Use a separate Vector2 instance\n            // Calculate outward normal using the cross product concept (for 2D)\n            const edgeVector = toNext.sub(toPrev); // Vector along the edge (next - prev)\n            const outwardNormal = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(-edgeVector.y, edgeVector.x); // Perpendicular vector\n            if (outwardNormal.lengthSq() < 1e-12) return; // Skip if normal is zero length\n            outwardNormal.normalize();\n            outwardNormal.multiplyScalar(cappedForceSize);\n            particle.applyForce(outwardNormal);\n        });\n    }\n    // Collision with Static Obstacles\n    collideWithStaticShape(ctx, shapeType, shapeParams) {\n        if (!shapeType || !shapeParams || !shapeParams.letter) return;\n        // For letter shapes\n        if (shapeType === 'letter' && shapeParams.letter) {\n            const letterCenterX = shapeParams.x + shapeParams.size / 2;\n            const letterCenterY = shapeParams.y + shapeParams.size / 2;\n            // Cache letter bounds for optimization\n            const letterBounds = {\n                minX: shapeParams.x,\n                minY: shapeParams.y,\n                maxX: shapeParams.x + shapeParams.size,\n                maxY: shapeParams.y + shapeParams.size\n            };\n            // Check ALL particles for collision with the letter shape\n            for(let i = 0; i < this.particles.length; i++){\n                const particle = this.particles[i];\n                // Quick bounds check first (simple optimization)\n                if (particle.pos.x >= letterBounds.minX - 5 && particle.pos.x <= letterBounds.maxX + 5 && particle.pos.y >= letterBounds.minY - 5 && particle.pos.y <= letterBounds.maxY + 5) {\n                    // Test if particle is actually inside the letter shape\n                    const isInside = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isPointInLetter)(ctx, shapeParams.letter, letterCenterX, letterCenterY, shapeParams.size, particle.pos.x, particle.pos.y);\n                    if (isInside) {\n                        // Calculate vector from center of letter to particle\n                        const toParticle = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(particle.pos.x - letterCenterX, particle.pos.y - letterCenterY);\n                        // If vector is near zero, use a random direction\n                        if (toParticle.lengthSq() < 0.1) {\n                            const randomAngle = Math.random() * Math.PI * 2;\n                            toParticle.set(Math.cos(randomAngle), Math.sin(randomAngle));\n                        }\n                        // Normalize and apply a strong push force\n                        toParticle.normalize();\n                        // Use a strong push force\n                        const pushForce = 3.0;\n                        toParticle.multiplyScalar(pushForce);\n                        // Apply this strong force to immediately push the particle out\n                        particle.applyForce(toParticle);\n                        // Also directly modify velocity to ensure immediate response\n                        const escapeVelocity = toParticle.clone().multiplyScalar(0.5);\n                        particle.vel.add(escapeVelocity);\n                        // Apply strong damping to other directions to prevent oscillation\n                        const dampingFactor = 0.3;\n                        particle.vel.multiplyScalar(dampingFactor);\n                        // For severely stuck particles, teleport them slightly outside\n                        if (particle.stuckFrames === undefined) {\n                            particle.stuckFrames = 0;\n                        }\n                        particle.stuckFrames++;\n                        // If stuck for multiple frames, teleport it out\n                        if (particle.stuckFrames > 5) {\n                            // Calculate escape position (outside the letter)\n                            const escapeDist = Math.max(10, shapeParams.size * 0.1);\n                            const escapePos = toParticle.clone().normalize().multiplyScalar(escapeDist);\n                            // Move particle directly\n                            particle.pos.x += escapePos.x;\n                            particle.pos.y += escapePos.y;\n                            // Reset stuck counter\n                            particle.stuckFrames = 0;\n                        }\n                        // Check if the particle is within an enclosed space\n                        const isEnclosed = (()=>{\n                            const rayCount = 16;\n                            const rayLength = shapeParams.size * 0.5;\n                            for(let i = 0; i < rayCount; i++){\n                                const angle = i / rayCount * Math.PI * 2;\n                                const rayX = particle.pos.x + Math.cos(angle) * rayLength;\n                                const rayY = particle.pos.y + Math.sin(angle) * rayLength;\n                                if (!(0,_utils__WEBPACK_IMPORTED_MODULE_2__.isPointInLetter)(ctx, shapeParams.letter, letterCenterX, letterCenterY, shapeParams.size, rayX, rayY)) {\n                                    return false;\n                                }\n                            }\n                            return true;\n                        })();\n                        // Modify repulsion direction if within an enclosed space\n                        if (isEnclosed) {\n                            // Invert the direction to guide the particle inwards\n                            toParticle.multiplyScalar(-1);\n                        }\n                    } else {\n                        // Not inside, reset stuck counter if it exists\n                        if (particle.stuckFrames !== undefined) {\n                            particle.stuckFrames = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    draw(ctx, fillColor, strokeColor, staticShapeType, staticShapeParams) {\n        var _this_particles_;\n        if (this.particles.length < 2) return;\n        ctx.beginPath();\n        // Ensure first particle exists before moving to it\n        if (!((_this_particles_ = this.particles[0]) === null || _this_particles_ === void 0 ? void 0 : _this_particles_.pos)) {\n            console.warn(\"First particle missing in draw\");\n            return;\n        }\n        ctx.moveTo(this.particles[0].pos.x, this.particles[0].pos.y);\n        for(let i = 1; i <= this.edgePointCount; i++){\n            var _this_particles_currentIndex;\n            const currentIndex = i % this.edgePointCount;\n            if ((_this_particles_currentIndex = this.particles[currentIndex]) === null || _this_particles_currentIndex === void 0 ? void 0 : _this_particles_currentIndex.pos) {\n                ctx.lineTo(this.particles[currentIndex].pos.x, this.particles[currentIndex].pos.y);\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(currentIndex, \" during draw\"));\n                ctx.closePath();\n                break;\n            }\n        }\n        ctx.closePath(); // Close path after loop\n        // Check context state before filling/stroking\n        if (ctx.fillStyle !== fillColor) ctx.fillStyle = fillColor;\n        if (ctx.strokeStyle !== strokeColor) ctx.strokeStyle = strokeColor;\n        ctx.lineWidth = 1;\n        ctx.fill();\n        ctx.stroke();\n    }\n    // Get SVG path data for this blob\n    getSVGPath() {\n        if (this.particles.length < 2) return \"\";\n        let path = \"M \".concat(this.particles[0].pos.x.toFixed(2), \" \").concat(this.particles[0].pos.y.toFixed(2));\n        for(let i = 1; i <= this.edgePointCount; i++){\n            const particle = this.particles[i % this.edgePointCount];\n            if (particle === null || particle === void 0 ? void 0 : particle.pos) {\n                path += \" L \".concat(particle.pos.x.toFixed(2), \" \").concat(particle.pos.y.toFixed(2));\n            } else {\n                console.warn(\"Particle or position undefined at index \".concat(i % this.edgePointCount, \" during SVG path generation\"));\n                return path + \" Z\";\n            }\n        }\n        path += \" Z\";\n        return path;\n    }\n    update(blobs, springTension, canvasWidth, canvasHeight, margin, isRoundedContainer, interactionStrength, maxExpansionFactor, gravity, damping, staticShapeType, staticShapeParams, ctx) {\n        // --- Force Application Phase ---\n        // Apply internal forces first (pressure, springs)\n        this.maintainPressure();\n        this.springs.forEach((spring)=>spring.update(springTension));\n        // Apply external forces (gravity, inter-blob repulsion, static collision)\n        this.particles.forEach((particle)=>{\n            particle.applyForce(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, gravity * 0.1)); // Apply gravity per particle\n        });\n        this.repelBlobs(blobs, interactionStrength);\n        if (ctx && staticShapeType && staticShapeParams) {\n            this.collideWithStaticShape(ctx, staticShapeType, staticShapeParams);\n        }\n        // --- [DEBUG] Draw rays for enclosed space check ---\n        if (ctx && staticShapeType === 'letter' && staticShapeParams) {\n            const { letterCenterX, letterCenterY, size, letter } = staticShapeParams;\n            const rayCount = 16;\n            const rayLength = size * 0.5;\n            for(let i = 0; i < rayCount; i++){\n                const angle = i / rayCount * Math.PI * 2;\n                const rayX = this.centre.x + Math.cos(angle) * rayLength;\n                const rayY = this.centre.y + Math.sin(angle) * rayLength;\n                ctx.beginPath();\n                ctx.moveTo(this.centre.x, this.centre.y);\n                ctx.lineTo(rayX, rayY);\n                ctx.strokeStyle = 'red';\n                ctx.lineWidth = 0.5;\n                ctx.stroke();\n            }\n        }\n        // --- [DEBUG] End draw rays for enclosed space check ---\n        // --- Update Phase ---\n        // Update particles using applied forces and damping\n        this.particles.forEach((particle)=>{\n            particle.update(canvasWidth, canvasHeight, margin, isRoundedContainer, damping);\n        });\n        // Update blob state based on new particle positions\n        this.updateCentre();\n        this.updateMaxRadius();\n        // Apply growth after updates\n        this.grow(maxExpansionFactor);\n    }\n    constructor(x, y, edgePointCount, startSize, repelDistance){\n        this.pressureConstant = 0.08 // Pressure constant\n        ;\n        this.maxRepulsionForce = 0.5 // Cap for repulsion force magnitude\n        ;\n        this.id = Math.random();\n        this.centre = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(x, y);\n        this.edgePointCount = edgePointCount;\n        this.particles = [];\n        this.springs = [];\n        this.maxRadius = Math.max(1, startSize); // Ensure startSize is at least 1\n        this.initialArea = Math.PI * this.maxRadius * this.maxRadius;\n        this.targetArea = this.initialArea;\n        this.repelDistance = repelDistance;\n        this.setup();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYmxvYi1zaW11bGF0aW9uL2Jsb2IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0M7QUFDTTtBQUNKO0FBQ1EsQ0FBQyxzQ0FBc0M7QUFFakYsb0NBQW9DO0FBQ3BDLE1BQU1JLFVBQVUsSUFBSUosMENBQU9BO0FBRTNCLHFFQUFxRTtBQUM5RCxNQUFNSztJQTBCWEMsUUFBUTtRQUNOLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxPQUFPLENBQUNELE1BQU0sR0FBRztRQUV0QixNQUFNRSxhQUFhLElBQUksQ0FBQ0MsU0FBUyxFQUFFLHFDQUFxQztRQUN4RSxNQUFNQyxZQUFZLEtBQU1FLEVBQUUsR0FBRyxJQUFLLElBQUksQ0FBQ0MsY0FBYztRQUNyRCx3REFBd0Q7UUFDeEQsTUFBTUMsc0JBQXNCSCxLQUFLSSxHQUFHLENBQUMsTUFBTVAsYUFBYUcsS0FBS0ssR0FBRyxDQUFDTCxLQUFLQyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxjQUFjLElBQUk7UUFFbEcsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixjQUFjLEVBQUVJLElBQUs7WUFDNUMsTUFBTUMsUUFBUUQsSUFBSVA7WUFDbEIsTUFBTVMsSUFBSVIsS0FBS1MsR0FBRyxDQUFDRixTQUFTVixhQUFhLElBQUksQ0FBQ2EsTUFBTSxDQUFDRixDQUFDO1lBQ3RELE1BQU1HLElBQUlYLEtBQUtLLEdBQUcsQ0FBQ0UsU0FBU1YsYUFBYSxJQUFJLENBQUNhLE1BQU0sQ0FBQ0MsQ0FBQztZQUN0RCxJQUFJLENBQUNqQixTQUFTLENBQUNrQixJQUFJLENBQUMsSUFBSXhCLCtDQUFRQSxDQUFDb0IsR0FBR0c7WUFFcEMsSUFBSUwsSUFBSSxHQUFHO2dCQUNULElBQUksQ0FBQ1YsT0FBTyxDQUFDZ0IsSUFBSSxDQUFDLElBQUl2QiwyQ0FBTUEsQ0FBQyxJQUFJLENBQUNLLFNBQVMsQ0FBQ1ks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LElBQUksQ0FBQ1IsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDRSxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNFLFNBQVMsR0FBR0UsS0FBS0ksR0FBRyxDQUFDLEdBQUdxSSxZQUFZLGlDQUFpQztRQUMxRSxJQUFJLENBQUNoRixXQUFXLEdBQUd6RCxLQUFLQyxFQUFFLEdBQUcsSUFBSSxDQUFDSCxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO1FBQzVELElBQUksQ0FBQzZELFVBQVUsR0FBRyxJQUFJLENBQUNGLFdBQVc7UUFDbEMsSUFBSSxDQUFDekIsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUN2QyxLQUFLO0lBQ1o7QUFxWUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW5pZWwvRGV2ZWxvcGVyL2VtYXJvY2tzL2NvbXBvbmVudHMvYmxvYi1zaW11bGF0aW9uL2Jsb2IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgUGFydGljbGUgfSBmcm9tIFwiLi9wYXJ0aWNsZVwiO1xuaW1wb3J0IHsgU3ByaW5nIH0gZnJvbSBcIi4vc3ByaW5nXCI7XG5pbXBvcnQgeyBpc1BvaW50SW5MZXR0ZXIgfSBmcm9tIFwiLi91dGlsc1wiOyAvLyBJbXBvcnQgdGhlIGlzUG9pbnRJbkxldHRlciBmdW5jdGlvblxuXG4vLyBUZW1wb3JhcnkgdmVjdG9yIGZvciBjYWxjdWxhdGlvbnNcbmNvbnN0IHRlbXBWZWMgPSBuZXcgVmVjdG9yMigpO1xuXG4vLyBCbG9iIENsYXNzIC0gcmVwcmVzZW50cyBhIGNvbXBsZXRlIGJsb2Igd2l0aCBwYXJ0aWNsZXMgYW5kIHNwcmluZ3NcbmV4cG9ydCBjbGFzcyBCbG9iIHtcbiAgY2VudHJlOiBWZWN0b3IyO1xuICBtYXhSYWRpdXM6IG51bWJlcjsgLy8gRHluYW1pYyByYWRpdXMgYmFzZWQgb24gcGFydGljbGUgcG9zaXRpb25zXG4gIGVkZ2VQb2ludENvdW50OiBudW1iZXI7XG4gIHBhcnRpY2xlczogUGFydGljbGVbXTtcbiAgc3ByaW5nczogU3ByaW5nW107XG5cbiAgaW5pdGlhbEFyZWE6IG51bWJlcjtcbiAgdGFyZ2V0QXJlYTogbnVtYmVyO1xuICByZXBlbERpc3RhbmNlOiBudW1iZXI7XG4gIHByZXNzdXJlQ29uc3RhbnQ6IG51bWJlciA9IDAuMDg7IC8vIFByZXNzdXJlIGNvbnN0YW50XG4gIG1heFJlcHVsc2lvbkZvcmNlOiBudW1iZXIgPSAwLjU7IC8vIENhcCBmb3IgcmVwdWxzaW9uIGZvcmNlIG1hZ25pdHVkZVxuICBpZDogbnVtYmVyID0gTWF0aC5yYW5kb20oKTtcblxuICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgZWRnZVBvaW50Q291bnQ6IG51bWJlciwgc3RhcnRTaXplOiBudW1iZXIsIHJlcGVsRGlzdGFuY2U6IG51bWJlcikge1xuICAgIHRoaXMuY2VudHJlID0gbmV3IFZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy5lZGdlUG9pbnRDb3VudCA9IGVkZ2VQb2ludENvdW50O1xuICAgIHRoaXMucGFydGljbGVzID0gW107XG4gICAgdGhpcy5zcHJpbmdzID0gW107XG4gICAgdGhpcy5tYXhSYWRpdXMgPSBNYXRoLm1heCgxLCBzdGFydFNpemUpOyAvLyBFbnN1cmUgc3RhcnRTaXplIGlzIGF0IGxlYXN0IDFcbiAgICB0aGlzLmluaXRpYWxBcmVhID0gTWF0aC5QSSAqIHRoaXMubWF4UmFkaXVzICogdGhpcy5tYXhSYWRpdXM7XG4gICAgdGhpcy50YXJnZXRBcmVhID0gdGhpcy5pbml0aWFsQXJlYTtcbiAgICB0aGlzLnJlcGVsRGlzdGFuY2UgPSByZXBlbERpc3RhbmNlO1xuICAgIHRoaXMuc2V0dXAoKTtcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMucGFydGljbGVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zcHJpbmdzLmxlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBzYWZlUmFkaXVzID0gdGhpcy5tYXhSYWRpdXM7IC8vIEFscmVhZHkgZW5zdXJlZCA+IDAgaW4gY29uc3RydWN0b3JcbiAgICBjb25zdCBhbmdsZVN0ZXAgPSAoTWF0aC5QSSAqIDIpIC8gdGhpcy5lZGdlUG9pbnRDb3VudDtcbiAgICAvLyBFbnN1cmUgaW5pdGlhbFNwcmluZ0xlbmd0aCBpcyBwb3NpdGl2ZSBhbmQgcmVhc29uYWJsZVxuICAgIGNvbnN0IGluaXRpYWxTcHJpbmdMZW5ndGggPSBNYXRoLm1heCgxZS02LCBzYWZlUmFkaXVzICogTWF0aC5zaW4oTWF0aC5QSSAvIHRoaXMuZWRnZVBvaW50Q291bnQpICogMik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRnZVBvaW50Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogYW5nbGVTdGVwO1xuICAgICAgY29uc3QgeCA9IE1hdGguY29zKGFuZ2xlKSAqIHNhZmVSYWRpdXMgKyB0aGlzLmNlbnRyZS54O1xuICAgICAgY29uc3QgeSA9IE1hdGguc2luKGFuZ2xlKSAqIHNhZmVSYWRpdXMgKyB0aGlzLmNlbnRyZS55O1xuICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaChuZXcgUGFydGljbGUoeCwgeSkpO1xuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5zcHJpbmdzLnB1c2gobmV3IFNwcmluZyh0aGlzLnBhcnRpY2xlc1tpXSwgdGhpcy5wYXJ0aWNsZXNbaSAtIDFdLCBpbml0aWFsU3ByaW5nTGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3ByaW5ncy5wdXNoKG5ldyBTcHJpbmcodGhpcy5wYXJ0aWNsZXNbMF0sIHRoaXMucGFydGljbGVzW3RoaXMuZWRnZVBvaW50Q291bnQgLSAxXSwgaW5pdGlhbFNwcmluZ0xlbmd0aCkpO1xuICB9XG5cbiAgdXBkYXRlQ2VudHJlKCkge1xuICAgIGlmICh0aGlzLnBhcnRpY2xlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB0aGlzLmNlbnRyZS5zZXQoMCwgMCk7XG4gICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChwID0+IHRoaXMuY2VudHJlLmFkZChwLnBvcykpO1xuICAgIHRoaXMuY2VudHJlLmRpdmlkZVNjYWxhcih0aGlzLnBhcnRpY2xlcy5sZW5ndGgpO1xuICB9XG5cbiAgdXBkYXRlTWF4UmFkaXVzKCkge1xuICAgIGlmICh0aGlzLnBhcnRpY2xlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubWF4UmFkaXVzID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1heERpc3RTcSA9IDA7XG4gICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGUpID0+IHtcbiAgICAgIGNvbnN0IGRpc3RTcSA9IHRoaXMuY2VudHJlLmRpc3RhbmNlVG9TcXVhcmVkKHBhcnRpY2xlLnBvcyk7XG4gICAgICBpZiAoZGlzdFNxID4gbWF4RGlzdFNxKSBtYXhEaXN0U3EgPSBkaXN0U3E7XG4gICAgfSk7XG4gICAgdGhpcy5tYXhSYWRpdXMgPSBNYXRoLnNxcnQobWF4RGlzdFNxKTtcbiAgfVxuXG4gIC8vIFJlcGVsIG90aGVyIGJsb2JzXG4gIHJlcGVsQmxvYnMoYmxvYnM6IEJsb2JbXSwgaW50ZXJhY3Rpb25TdHJlbmd0aDogbnVtYmVyKSB7XG4gICAgYmxvYnMuZm9yRWFjaCgoYmxvYkIpID0+IHtcbiAgICAgIGlmICh0aGlzLmlkID09PSBibG9iQi5pZCkgcmV0dXJuO1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgcmVwZWxEaXN0YW5jZSBmb3IgYm90aCBibG9icyB0byBlbnN1cmUgY29uc2lzdGVuY3lcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcGVsRGlzdGFuY2UgPSBNYXRoLm1heCh0aGlzLnJlcGVsRGlzdGFuY2UsIGJsb2JCLnJlcGVsRGlzdGFuY2UpO1xuICAgICAgXG4gICAgICBjb25zdCBkaXN0QmV0d2VlbkNlbnRlcnNTcSA9IHRoaXMuY2VudHJlLmRpc3RhbmNlVG9TcXVhcmVkKGJsb2JCLmNlbnRyZSk7XG4gICAgICAvLyBVc2UgcmFkaWkgc3F1YXJlZCBmb3IgY29tcGFyaXNvbiB0byBhdm9pZCBzcXJ0XG4gICAgICBjb25zdCBjb21iaW5lZFJhZGlpID0gdGhpcy5tYXhSYWRpdXMgKyBibG9iQi5tYXhSYWRpdXM7XG4gICAgICBjb25zdCBpbnRlcmFjdGlvblJhbmdlU3EgPSBNYXRoLnBvdyhjb21iaW5lZFJhZGlpICsgZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSwgMik7XG5cbiAgICAgIC8vIE9wdGltaXphdGlvbjogQnJvYWQgcGhhc2UgY2hlY2sgYmFzZWQgb24gY2VudGVycyBhbmQgcmFkaWkgKyByZXBlbCBkaXN0YW5jZVxuICAgICAgaWYgKGRpc3RCZXR3ZWVuQ2VudGVyc1NxID4gaW50ZXJhY3Rpb25SYW5nZVNxKSByZXR1cm47XG5cbiAgICAgIC8vIE5hcnJvdyBwaGFzZTogQ2hlY2sgcGFydGljbGUgcGFpcnNcbiAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlQSkgPT4ge1xuICAgICAgICBibG9iQi5wYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGVCKSA9PiB7XG4gICAgICAgICAgdGVtcFZlYy5jb3B5KHBhcnRpY2xlQS5wb3MpLnN1YihwYXJ0aWNsZUIucG9zKTtcbiAgICAgICAgICBjb25zdCBkaXN0U3EgPSB0ZW1wVmVjLmxlbmd0aFNxKCk7IC8vIFVzZSBzcXVhcmVkIGRpc3RhbmNlXG5cbiAgICAgICAgICAvLyBBcHBseSByZXB1bHNpb24gZm9yY2UgaWYgd2l0aGluIHJlcGVsRGlzdGFuY2Ugc3F1YXJlZFxuICAgICAgICAgIGNvbnN0IHJlcGVsRGlzdFNxID0gZWZmZWN0aXZlUmVwZWxEaXN0YW5jZSAqIGVmZmVjdGl2ZVJlcGVsRGlzdGFuY2U7XG4gICAgICAgICAgaWYgKGRpc3RTcSA+IDFlLTEyICYmIGRpc3RTcSA8IHJlcGVsRGlzdFNxKSB7IC8vIENvbXBhcmUgc3F1YXJlZCBkaXN0YW5jZXNcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZGlzdFNxKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXAgPSBlZmZlY3RpdmVSZXBlbERpc3RhbmNlIC0gZGlzdDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlIG1hZ25pdHVkZSBiYXNlZCBvbiBvdmVybGFwIGFuZCBzdHJlbmd0aFxuICAgICAgICAgICAgbGV0IGZvcmNlTWFnbml0dWRlID0gb3ZlcmxhcCAqIGludGVyYWN0aW9uU3RyZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIENhcCB0aGUgZm9yY2UgbWFnbml0dWRlXG4gICAgICAgICAgICBmb3JjZU1hZ25pdHVkZSA9IE1hdGgubWluKGZvcmNlTWFnbml0dWRlLCB0aGlzLm1heFJlcHVsc2lvbkZvcmNlKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGRpcmVjdGlvbiB2ZWN0b3IgKHJldXNlIHRlbXBWZWMpIGFuZCBhcHBseSBtYWduaXR1ZGVcbiAgICAgICAgICAgIHRlbXBWZWMubXVsdGlwbHlTY2FsYXIoZm9yY2VNYWduaXR1ZGUgLyBkaXN0KTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgZm9yY2VzIGVuc3VyaW5nIHRoZXkgYXJlIGZpbml0ZVxuICAgICAgICAgICAgcGFydGljbGVBLmFwcGx5Rm9yY2UodGVtcFZlYyk7XG4gICAgICAgICAgICBwYXJ0aWNsZUIuYXBwbHlGb3JjZSh0ZW1wVmVjLm11bHRpcGx5U2NhbGFyKC0xKSk7IC8vIEFwcGx5IG9wcG9zaXRlIGZvcmNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGFyZWEoKTogbnVtYmVyIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGlmICh0aGlzLnBhcnRpY2xlcy5sZW5ndGggPCAzKSByZXR1cm4gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlUG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwMSA9IHRoaXMucGFydGljbGVzW2ldLnBvcztcbiAgICAgIGNvbnN0IHAyID0gdGhpcy5wYXJ0aWNsZXNbKGkgKyAxKSAlIHRoaXMuZWRnZVBvaW50Q291bnRdLnBvcztcbiAgICAgIHRvdGFsICs9IHAxLnggKiBwMi55IC0gcDIueCAqIHAxLnk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyh0b3RhbCAvIDIpO1xuICB9XG5cbiAgZ3JvdyhtYXhFeHBhbnNpb25GYWN0b3I6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmluaXRpYWxBcmVhIDw9IDApIHJldHVybjtcbiAgICBjb25zdCBtYXhUYXJnZXRBcmVhID0gdGhpcy5pbml0aWFsQXJlYSAqIE1hdGgubWF4KDEsIG1heEV4cGFuc2lvbkZhY3Rvcik7XG5cbiAgICBpZiAodGhpcy50YXJnZXRBcmVhIDwgbWF4VGFyZ2V0QXJlYSkge1xuICAgICAgdGhpcy50YXJnZXRBcmVhICo9IDEuMDA1OyAvLyBTbG93IGdyb3d0aFxuICAgICAgdGhpcy50YXJnZXRBcmVhID0gTWF0aC5taW4odGhpcy50YXJnZXRBcmVhLCBtYXhUYXJnZXRBcmVhKTsgLy8gQ2xhbXAgdG8gbWF4XG4gICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldEFyZWEgPiBtYXhUYXJnZXRBcmVhKSB7XG4gICAgICB0aGlzLnRhcmdldEFyZWEgPSBtYXhUYXJnZXRBcmVhO1xuICAgIH1cbiAgfVxuXG4gIG1haW50YWluUHJlc3N1cmUoKSB7XG4gICAgY29uc3QgY3VycmVudEFyZWEgPSB0aGlzLmFyZWE7XG4gICAgaWYgKGN1cnJlbnRBcmVhIDwgMWUtNiB8fCB0aGlzLnRhcmdldEFyZWEgPCAxZS02KSByZXR1cm47XG5cbiAgICAvLyBNYWtlIHByZXNzdXJlIGZvcmNlIHByb3BvcnRpb25hbCB0byB0aGUgZGlmZmVyZW5jZSByYXRpbywgYnV0IHByZXZlbnQgZXh0cmVtZSBmb3JjZXNcbiAgICBjb25zdCBhcmVhUmF0aW8gPSB0aGlzLnRhcmdldEFyZWEgLyBjdXJyZW50QXJlYTtcbiAgICAvLyBDbGFtcCB0aGUgcmF0aW8gdG8gcHJldmVudCBleGNlc3NpdmUgZm9yY2VzIHdoZW4gYXJlYSBpcyB2ZXJ5IHNtYWxsXG4gICAgY29uc3QgY2xhbXBlZFJhdGlvID0gTWF0aC5tYXgoMC41LCBNYXRoLm1pbihhcmVhUmF0aW8sIDIuMCkpO1xuICAgIGNvbnN0IHByZXNzdXJlRGlmZmVyZW5jZSA9IGNsYW1wZWRSYXRpbyAtIDE7XG5cbiAgICBjb25zdCBmb3JjZVNpemUgPSBwcmVzc3VyZURpZmZlcmVuY2UgKiB0aGlzLnByZXNzdXJlQ29uc3RhbnQ7XG5cbiAgICAvLyBMaW1pdCB0aGUgbWF4aW11bSBmb3JjZSBzaXplIHRvIHByZXZlbnQgaW5zdGFiaWxpdHlcbiAgICBjb25zdCBtYXhQcmVzc3VyZUZvcmNlID0gMC4xOyAvLyBFeGFtcGxlIGNhcFxuICAgIGNvbnN0IGNhcHBlZEZvcmNlU2l6ZSA9IE1hdGgubWF4KC1tYXhQcmVzc3VyZUZvcmNlLCBNYXRoLm1pbihmb3JjZVNpemUsIG1heFByZXNzdXJlRm9yY2UpKTtcblxuICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlLCBpKSA9PiB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5wYXJ0aWNsZXNbKGkgKyB0aGlzLmVkZ2VQb2ludENvdW50IC0gMSkgJSB0aGlzLmVkZ2VQb2ludENvdW50XTtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnBhcnRpY2xlc1soaSArIDEpICUgdGhpcy5lZGdlUG9pbnRDb3VudF07XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBlZGdlIHZlY3RvcnMgZnJvbSB0aGUgcGFydGljbGUgdG8gaXRzIG5laWdoYm9yc1xuICAgICAgY29uc3QgdG9QcmV2ID0gdGVtcFZlYy5jb3B5KHByZXYucG9zKS5zdWIocGFydGljbGUucG9zKTtcbiAgICAgIGNvbnN0IHRvTmV4dCA9IG5ldyBWZWN0b3IyKCkuY29weShuZXh0LnBvcykuc3ViKHBhcnRpY2xlLnBvcyk7IC8vIFVzZSBhIHNlcGFyYXRlIFZlY3RvcjIgaW5zdGFuY2VcblxuICAgICAgLy8gQ2FsY3VsYXRlIG91dHdhcmQgbm9ybWFsIHVzaW5nIHRoZSBjcm9zcyBwcm9kdWN0IGNvbmNlcHQgKGZvciAyRClcbiAgICAgIGNvbnN0IGVkZ2VWZWN0b3IgPSB0b05leHQuc3ViKHRvUHJldik7IC8vIFZlY3RvciBhbG9uZyB0aGUgZWRnZSAobmV4dCAtIHByZXYpXG4gICAgICBjb25zdCBvdXR3YXJkTm9ybWFsID0gbmV3IFZlY3RvcjIoLWVkZ2VWZWN0b3IueSwgZWRnZVZlY3Rvci54KTsgLy8gUGVycGVuZGljdWxhciB2ZWN0b3JcblxuICAgICAgaWYgKG91dHdhcmROb3JtYWwubGVuZ3RoU3EoKSA8IDFlLTEyKSByZXR1cm47IC8vIFNraXAgaWYgbm9ybWFsIGlzIHplcm8gbGVuZ3RoXG5cbiAgICAgIG91dHdhcmROb3JtYWwubm9ybWFsaXplKCk7XG4gICAgICBvdXR3YXJkTm9ybWFsLm11bHRpcGx5U2NhbGFyKGNhcHBlZEZvcmNlU2l6ZSk7XG4gICAgICBwYXJ0aWNsZS5hcHBseUZvcmNlKG91dHdhcmROb3JtYWwpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29sbGlzaW9uIHdpdGggU3RhdGljIE9ic3RhY2xlc1xuICBjb2xsaWRlV2l0aFN0YXRpY1NoYXBlKFxuICAgIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICAgIHNoYXBlVHlwZTogJ2xldHRlcicgfCBudWxsLFxuICAgIHNoYXBlUGFyYW1zOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBzaXplOiBudW1iZXI7IGxldHRlcj86IHN0cmluZyB9IHwgbnVsbFxuICApIHtcbiAgICBpZiAoIXNoYXBlVHlwZSB8fCAhc2hhcGVQYXJhbXMgfHwgIXNoYXBlUGFyYW1zLmxldHRlcikgcmV0dXJuO1xuXG4gICAgLy8gRm9yIGxldHRlciBzaGFwZXNcbiAgICBpZiAoc2hhcGVUeXBlID09PSAnbGV0dGVyJyAmJiBzaGFwZVBhcmFtcy5sZXR0ZXIpIHtcbiAgICAgIGNvbnN0IGxldHRlckNlbnRlclggPSBzaGFwZVBhcmFtcy54ICsgc2hhcGVQYXJhbXMuc2l6ZSAvIDI7XG4gICAgICBjb25zdCBsZXR0ZXJDZW50ZXJZID0gc2hhcGVQYXJhbXMueSArIHNoYXBlUGFyYW1zLnNpemUgLyAyO1xuICAgICAgXG4gICAgICAvLyBDYWNoZSBsZXR0ZXIgYm91bmRzIGZvciBvcHRpbWl6YXRpb25cbiAgICAgIGNvbnN0IGxldHRlckJvdW5kcyA9IHtcbiAgICAgICAgbWluWDogc2hhcGVQYXJhbXMueCxcbiAgICAgICAgbWluWTogc2hhcGVQYXJhbXMueSxcbiAgICAgICAgbWF4WDogc2hhcGVQYXJhbXMueCArIHNoYXBlUGFyYW1zLnNpemUsXG4gICAgICAgIG1heFk6IHNoYXBlUGFyYW1zLnkgKyBzaGFwZVBhcmFtcy5zaXplLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgQUxMIHBhcnRpY2xlcyBmb3IgY29sbGlzaW9uIHdpdGggdGhlIGxldHRlciBzaGFwZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnRpY2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGVzW2ldO1xuICAgICAgICBcbiAgICAgICAgLy8gUXVpY2sgYm91bmRzIGNoZWNrIGZpcnN0IChzaW1wbGUgb3B0aW1pemF0aW9uKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFydGljbGUucG9zLnggPj0gbGV0dGVyQm91bmRzLm1pblggLSA1ICYmIFxuICAgICAgICAgIHBhcnRpY2xlLnBvcy54IDw9IGxldHRlckJvdW5kcy5tYXhYICsgNSAmJiBcbiAgICAgICAgICBwYXJ0aWNsZS5wb3MueSA+PSBsZXR0ZXJCb3VuZHMubWluWSAtIDUgJiYgXG4gICAgICAgICAgcGFydGljbGUucG9zLnkgPD0gbGV0dGVyQm91bmRzLm1heFkgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRlc3QgaWYgcGFydGljbGUgaXMgYWN0dWFsbHkgaW5zaWRlIHRoZSBsZXR0ZXIgc2hhcGVcbiAgICAgICAgICBjb25zdCBpc0luc2lkZSA9IGlzUG9pbnRJbkxldHRlcihcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHNoYXBlUGFyYW1zLmxldHRlcixcbiAgICAgICAgICAgIGxldHRlckNlbnRlclgsXG4gICAgICAgICAgICBsZXR0ZXJDZW50ZXJZLFxuICAgICAgICAgICAgc2hhcGVQYXJhbXMuc2l6ZSxcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvcy54LFxuICAgICAgICAgICAgcGFydGljbGUucG9zLnlcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpc0luc2lkZSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBsZXR0ZXIgdG8gcGFydGljbGVcbiAgICAgICAgICAgIGNvbnN0IHRvUGFydGljbGUgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgICAgICAgcGFydGljbGUucG9zLnggLSBsZXR0ZXJDZW50ZXJYLFxuICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3MueSAtIGxldHRlckNlbnRlcllcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHZlY3RvciBpcyBuZWFyIHplcm8sIHVzZSBhIHJhbmRvbSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmICh0b1BhcnRpY2xlLmxlbmd0aFNxKCkgPCAwLjEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICAgIHRvUGFydGljbGUuc2V0KE1hdGguY29zKHJhbmRvbUFuZ2xlKSwgTWF0aC5zaW4ocmFuZG9tQW5nbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFuZCBhcHBseSBhIHN0cm9uZyBwdXNoIGZvcmNlXG4gICAgICAgICAgICB0b1BhcnRpY2xlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVc2UgYSBzdHJvbmcgcHVzaCBmb3JjZVxuICAgICAgICAgICAgY29uc3QgcHVzaEZvcmNlID0gMy4wO1xuICAgICAgICAgICAgdG9QYXJ0aWNsZS5tdWx0aXBseVNjYWxhcihwdXNoRm9yY2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcHBseSB0aGlzIHN0cm9uZyBmb3JjZSB0byBpbW1lZGlhdGVseSBwdXNoIHRoZSBwYXJ0aWNsZSBvdXRcbiAgICAgICAgICAgIHBhcnRpY2xlLmFwcGx5Rm9yY2UodG9QYXJ0aWNsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFsc28gZGlyZWN0bHkgbW9kaWZ5IHZlbG9jaXR5IHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZVZlbG9jaXR5ID0gdG9QYXJ0aWNsZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWwuYWRkKGVzY2FwZVZlbG9jaXR5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXBwbHkgc3Ryb25nIGRhbXBpbmcgdG8gb3RoZXIgZGlyZWN0aW9ucyB0byBwcmV2ZW50IG9zY2lsbGF0aW9uXG4gICAgICAgICAgICBjb25zdCBkYW1waW5nRmFjdG9yID0gMC4zO1xuICAgICAgICAgICAgcGFydGljbGUudmVsLm11bHRpcGx5U2NhbGFyKGRhbXBpbmdGYWN0b3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3Igc2V2ZXJlbHkgc3R1Y2sgcGFydGljbGVzLCB0ZWxlcG9ydCB0aGVtIHNsaWdodGx5IG91dHNpZGVcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5zdHVja0ZyYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcnRpY2xlLnN0dWNrRnJhbWVzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFydGljbGUuc3R1Y2tGcmFtZXMrKztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgc3R1Y2sgZm9yIG11bHRpcGxlIGZyYW1lcywgdGVsZXBvcnQgaXQgb3V0XG4gICAgICAgICAgICBpZiAocGFydGljbGUuc3R1Y2tGcmFtZXMgPiA1KSB7XG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBlc2NhcGUgcG9zaXRpb24gKG91dHNpZGUgdGhlIGxldHRlcilcbiAgICAgICAgICAgICAgY29uc3QgZXNjYXBlRGlzdCA9IE1hdGgubWF4KDEwLCBzaGFwZVBhcmFtcy5zaXplICogMC4xKTtcbiAgICAgICAgICAgICAgY29uc3QgZXNjYXBlUG9zID0gdG9QYXJ0aWNsZS5jbG9uZSgpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGVzY2FwZURpc3QpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gTW92ZSBwYXJ0aWNsZSBkaXJlY3RseVxuICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3MueCArPSBlc2NhcGVQb3MueDtcbiAgICAgICAgICAgICAgcGFydGljbGUucG9zLnkgKz0gZXNjYXBlUG9zLnk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZXNldCBzdHVjayBjb3VudGVyXG4gICAgICAgICAgICAgIHBhcnRpY2xlLnN0dWNrRnJhbWVzID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhcnRpY2xlIGlzIHdpdGhpbiBhbiBlbmNsb3NlZCBzcGFjZVxuICAgICAgICAgICAgY29uc3QgaXNFbmNsb3NlZCA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJheUNvdW50ID0gMTY7XG4gICAgICAgICAgICAgIGNvbnN0IHJheUxlbmd0aCA9IHNoYXBlUGFyYW1zLnNpemUgKiAwLjU7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF5Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gKGkgLyByYXlDb3VudCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICBjb25zdCByYXlYID0gcGFydGljbGUucG9zLnggKyBNYXRoLmNvcyhhbmdsZSkgKiByYXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF5WSA9IHBhcnRpY2xlLnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogcmF5TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghaXNQb2ludEluTGV0dGVyKGN0eCwgc2hhcGVQYXJhbXMubGV0dGVyISwgbGV0dGVyQ2VudGVyWCwgbGV0dGVyQ2VudGVyWSwgc2hhcGVQYXJhbXMuc2l6ZSwgcmF5WCwgcmF5WSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAvLyBNb2RpZnkgcmVwdWxzaW9uIGRpcmVjdGlvbiBpZiB3aXRoaW4gYW4gZW5jbG9zZWQgc3BhY2VcbiAgICAgICAgICAgIGlmIChpc0VuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIC8vIEludmVydCB0aGUgZGlyZWN0aW9uIHRvIGd1aWRlIHRoZSBwYXJ0aWNsZSBpbndhcmRzXG4gICAgICAgICAgICAgIHRvUGFydGljbGUubXVsdGlwbHlTY2FsYXIoLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgaW5zaWRlLCByZXNldCBzdHVjayBjb3VudGVyIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnN0dWNrRnJhbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFydGljbGUuc3R1Y2tGcmFtZXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGZpbGxDb2xvcjogc3RyaW5nLCBzdHJva2VDb2xvcjogc3RyaW5nLCBzdGF0aWNTaGFwZVR5cGU6ICdsZXR0ZXInIHwgbnVsbCwgc3RhdGljU2hhcGVQYXJhbXM6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHNpemU6IG51bWJlcjsgbGV0dGVyPzogc3RyaW5nIH0gfCBudWxsKSB7XG4gICAgaWYgKHRoaXMucGFydGljbGVzLmxlbmd0aCA8IDIpIHJldHVybjtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAvLyBFbnN1cmUgZmlyc3QgcGFydGljbGUgZXhpc3RzIGJlZm9yZSBtb3ZpbmcgdG8gaXRcbiAgICBpZiAoIXRoaXMucGFydGljbGVzWzBdPy5wb3MpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkZpcnN0IHBhcnRpY2xlIG1pc3NpbmcgaW4gZHJhd1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4Lm1vdmVUbyh0aGlzLnBhcnRpY2xlc1swXS5wb3MueCwgdGhpcy5wYXJ0aWNsZXNbMF0ucG9zLnkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5lZGdlUG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpICUgdGhpcy5lZGdlUG9pbnRDb3VudDtcbiAgICAgIGlmICh0aGlzLnBhcnRpY2xlc1tjdXJyZW50SW5kZXhdPy5wb3MpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnBhcnRpY2xlc1tjdXJyZW50SW5kZXhdLnBvcy54LCB0aGlzLnBhcnRpY2xlc1tjdXJyZW50SW5kZXhdLnBvcy55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFydGljbGUgb3IgcG9zaXRpb24gdW5kZWZpbmVkIGF0IGluZGV4ICR7Y3VycmVudEluZGV4fSBkdXJpbmcgZHJhd2ApO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7IC8vIENsb3NlIHBhdGggYWZ0ZXIgbG9vcFxuXG4gICAgLy8gQ2hlY2sgY29udGV4dCBzdGF0ZSBiZWZvcmUgZmlsbGluZy9zdHJva2luZ1xuICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSBmaWxsQ29sb3IpIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3I7XG4gICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlQ29sb3IpIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gR2V0IFNWRyBwYXRoIGRhdGEgZm9yIHRoaXMgYmxvYlxuICBnZXRTVkdQYXRoKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMucGFydGljbGVzLmxlbmd0aCA8IDIpIHJldHVybiBcIlwiO1xuXG4gICAgbGV0IHBhdGggPSBgTSAke3RoaXMucGFydGljbGVzWzBdLnBvcy54LnRvRml4ZWQoMil9ICR7dGhpcy5wYXJ0aWNsZXNbMF0ucG9zLnkudG9GaXhlZCgyKX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5lZGdlUG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGVzW2kgJSB0aGlzLmVkZ2VQb2ludENvdW50XTtcbiAgICAgIGlmIChwYXJ0aWNsZT8ucG9zKSB7XG4gICAgICAgIHBhdGggKz0gYCBMICR7cGFydGljbGUucG9zLngudG9GaXhlZCgyKX0gJHtwYXJ0aWNsZS5wb3MueS50b0ZpeGVkKDIpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFBhcnRpY2xlIG9yIHBvc2l0aW9uIHVuZGVmaW5lZCBhdCBpbmRleCAke2kgJSB0aGlzLmVkZ2VQb2ludENvdW50fSBkdXJpbmcgU1ZHIHBhdGggZ2VuZXJhdGlvbmApO1xuICAgICAgICByZXR1cm4gcGF0aCArIFwiIFpcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoICs9IFwiIFpcIjtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHVwZGF0ZShcbiAgICBibG9iczogQmxvYltdLFxuICAgIHNwcmluZ1RlbnNpb246IG51bWJlcixcbiAgICBjYW52YXNXaWR0aDogbnVtYmVyLFxuICAgIGNhbnZhc0hlaWdodDogbnVtYmVyLFxuICAgIG1hcmdpbjogbnVtYmVyLFxuICAgIGlzUm91bmRlZENvbnRhaW5lcjogYm9vbGVhbixcbiAgICBpbnRlcmFjdGlvblN0cmVuZ3RoOiBudW1iZXIsXG4gICAgbWF4RXhwYW5zaW9uRmFjdG9yOiBudW1iZXIsXG4gICAgZ3Jhdml0eTogbnVtYmVyLFxuICAgIGRhbXBpbmc6IG51bWJlcixcbiAgICBzdGF0aWNTaGFwZVR5cGU6ICdsZXR0ZXInIHwgbnVsbCxcbiAgICBzdGF0aWNTaGFwZVBhcmFtczogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgc2l6ZTogbnVtYmVyOyBsZXR0ZXI/OiBzdHJpbmcgfSB8IG51bGwsXG4gICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsXG4gICkge1xuICAgIC8vIC0tLSBGb3JjZSBBcHBsaWNhdGlvbiBQaGFzZSAtLS1cbiAgICAvLyBBcHBseSBpbnRlcm5hbCBmb3JjZXMgZmlyc3QgKHByZXNzdXJlLCBzcHJpbmdzKVxuICAgIHRoaXMubWFpbnRhaW5QcmVzc3VyZSgpO1xuICAgIHRoaXMuc3ByaW5ncy5mb3JFYWNoKChzcHJpbmcpID0+IHNwcmluZy51cGRhdGUoc3ByaW5nVGVuc2lvbikpO1xuXG4gICAgLy8gQXBwbHkgZXh0ZXJuYWwgZm9yY2VzIChncmF2aXR5LCBpbnRlci1ibG9iIHJlcHVsc2lvbiwgc3RhdGljIGNvbGxpc2lvbilcbiAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSkgPT4ge1xuICAgICAgcGFydGljbGUuYXBwbHlGb3JjZShuZXcgVmVjdG9yMigwLCBncmF2aXR5ICogMC4xKSk7IC8vIEFwcGx5IGdyYXZpdHkgcGVyIHBhcnRpY2xlXG4gICAgfSk7XG4gICAgdGhpcy5yZXBlbEJsb2JzKGJsb2JzLCBpbnRlcmFjdGlvblN0cmVuZ3RoKTtcbiAgICBpZiAoY3R4ICYmIHN0YXRpY1NoYXBlVHlwZSAmJiBzdGF0aWNTaGFwZVBhcmFtcykge1xuICAgICAgdGhpcy5jb2xsaWRlV2l0aFN0YXRpY1NoYXBlKGN0eCwgc3RhdGljU2hhcGVUeXBlLCBzdGF0aWNTaGFwZVBhcmFtcyk7XG4gICAgfVxuXG4gICAgLy8gLS0tIFtERUJVR10gRHJhdyByYXlzIGZvciBlbmNsb3NlZCBzcGFjZSBjaGVjayAtLS1cbiAgICBpZiAoY3R4ICYmIHN0YXRpY1NoYXBlVHlwZSA9PT0gJ2xldHRlcicgJiYgc3RhdGljU2hhcGVQYXJhbXMpIHtcbiAgICAgIGNvbnN0IHsgbGV0dGVyQ2VudGVyWCwgbGV0dGVyQ2VudGVyWSwgc2l6ZSwgbGV0dGVyIH0gPSBzdGF0aWNTaGFwZVBhcmFtcztcbiAgICAgIGNvbnN0IHJheUNvdW50ID0gMTY7XG4gICAgICBjb25zdCByYXlMZW5ndGggPSBzaXplICogMC41O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKGkgLyByYXlDb3VudCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgY29uc3QgcmF5WCA9IHRoaXMuY2VudHJlLnggKyBNYXRoLmNvcyhhbmdsZSkgKiByYXlMZW5ndGg7XG4gICAgICAgIGNvbnN0IHJheVkgPSB0aGlzLmNlbnRyZS55ICsgTWF0aC5zaW4oYW5nbGUpICogcmF5TGVuZ3RoO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLmNlbnRyZS54LCB0aGlzLmNlbnRyZS55KTtcbiAgICAgICAgY3R4LmxpbmVUbyhyYXlYLCByYXlZKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tIFtERUJVR10gRW5kIGRyYXcgcmF5cyBmb3IgZW5jbG9zZWQgc3BhY2UgY2hlY2sgLS0tXG5cbiAgICAvLyAtLS0gVXBkYXRlIFBoYXNlIC0tLVxuICAgIC8vIFVwZGF0ZSBwYXJ0aWNsZXMgdXNpbmcgYXBwbGllZCBmb3JjZXMgYW5kIGRhbXBpbmdcbiAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSkgPT4ge1xuICAgICAgcGFydGljbGUudXBkYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIG1hcmdpbiwgaXNSb3VuZGVkQ29udGFpbmVyLCBkYW1waW5nKTtcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBibG9iIHN0YXRlIGJhc2VkIG9uIG5ldyBwYXJ0aWNsZSBwb3NpdGlvbnNcbiAgICB0aGlzLnVwZGF0ZUNlbnRyZSgpO1xuICAgIHRoaXMudXBkYXRlTWF4UmFkaXVzKCk7XG5cbiAgICAvLyBBcHBseSBncm93dGggYWZ0ZXIgdXBkYXRlc1xuICAgIHRoaXMuZ3JvdyhtYXhFeHBhbnNpb25GYWN0b3IpO1xuICB9XG59Il0sIm5hbWVzIjpbIlZlY3RvcjIiLCJQYXJ0aWNsZSIsIlNwcmluZyIsImlzUG9pbnRJbkxldHRlciIsInRlbXBWZWMiLCJCbG9iIiwic2V0dXAiLCJwYXJ0aWNsZXMiLCJsZW5ndGgiLCJzcHJpbmdzIiwic2FmZVJhZGl1cyIsIm1heFJhZGl1cyIsImFuZ2xlU3RlcCIsIk1hdGgiLCJQSSIsImVkZ2VQb2ludENvdW50IiwiaW5pdGlhbFNwcmluZ0xlbmd0aCIsIm1heCIsInNpbiIsImkiLCJhbmdsZSIsIngiLCJjb3MiLCJjZW50cmUiLCJ5IiwicHVzaCIsInVwZGF0ZUNlbnRyZSIsInNldCIsImZvckVhY2giLCJwIiwiYWRkIiwicG9zIiwiZGl2aWRlU2NhbGFyIiwidXBkYXRlTWF4UmFkaXVzIiwibWF4RGlzdFNxIiwicGFydGljbGUiLCJkaXN0U3EiLCJkaXN0YW5jZVRvU3F1YXJlZCIsInNxcnQiLCJyZXBlbEJsb2JzIiwiYmxvYnMiLCJpbnRlcmFjdGlvblN0cmVuZ3RoIiwiYmxvYkIiLCJpZCIsImVmZmVjdGl2ZVJlcGVsRGlzdGFuY2UiLCJyZXBlbERpc3RhbmNlIiwiZGlzdEJldHdlZW5DZW50ZXJzU3EiLCJjb21iaW5lZFJhZGlpIiwiaW50ZXJhY3Rpb25SYW5nZVNxIiwicG93IiwicGFydGljbGVBIiwicGFydGljbGVCIiwiY29weSIsInN1YiIsImxlbmd0aFNxIiwicmVwZWxEaXN0U3EiLCJkaXN0Iiwib3ZlcmxhcCIsImZvcmNlTWFnbml0dWRlIiwibWluIiwibWF4UmVwdWxzaW9uRm9yY2UiLCJtdWx0aXBseVNjYWxhciIsImFwcGx5Rm9yY2UiLCJhcmVhIiwidG90YWwiLCJwMSIsInAyIiwiYWJzIiwiZ3JvdyIsIm1heEV4cGFuc2lvbkZhY3RvciIsImluaXRpYWxBcmVhIiwibWF4VGFyZ2V0QXJlYSIsInRhcmdldEFyZWEiLCJtYWludGFpblByZXNzdXJlIiwiY3VycmVudEFyZWEiLCJhcmVhUmF0aW8iLCJjbGFtcGVkUmF0aW8iLCJwcmVzc3VyZURpZmZlcmVuY2UiLCJmb3JjZVNpemUiLCJwcmVzc3VyZUNvbnN0YW50IiwibWF4UHJlc3N1cmVGb3JjZSIsImNhcHBlZEZvcmNlU2l6ZSIsInByZXYiLCJuZXh0IiwidG9QcmV2IiwidG9OZXh0IiwiZWRnZVZlY3RvciIsIm91dHdhcmROb3JtYWwiLCJub3JtYWxpemUiLCJjb2xsaWRlV2l0aFN0YXRpY1NoYXBlIiwiY3R4Iiwic2hhcGVUeXBlIiwic2hhcGVQYXJhbXMiLCJsZXR0ZXIiLCJsZXR0ZXJDZW50ZXJYIiwic2l6ZSIsImxldHRlckNlbnRlclkiLCJsZXR0ZXJCb3VuZHMiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiaXNJbnNpZGUiLCJ0b1BhcnRpY2xlIiwicmFuZG9tQW5nbGUiLCJyYW5kb20iLCJwdXNoRm9yY2UiLCJlc2NhcGVWZWxvY2l0eSIsImNsb25lIiwidmVsIiwiZGFtcGluZ0ZhY3RvciIsInN0dWNrRnJhbWVzIiwidW5kZWZpbmVkIiwiZXNjYXBlRGlzdCIsImVzY2FwZVBvcyIsImlzRW5jbG9zZWQiLCJyYXlDb3VudCIsInJheUxlbmd0aCIsInJheVgiLCJyYXlZIiwiZHJhdyIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwic3RhdGljU2hhcGVUeXBlIiwic3RhdGljU2hhcGVQYXJhbXMiLCJiZWdpblBhdGgiLCJjb25zb2xlIiwid2FybiIsIm1vdmVUbyIsImN1cnJlbnRJbmRleCIsImxpbmVUbyIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiZmlsbCIsInN0cm9rZSIsImdldFNWR1BhdGgiLCJwYXRoIiwidG9GaXhlZCIsInVwZGF0ZSIsInNwcmluZ1RlbnNpb24iLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsIm1hcmdpbiIsImlzUm91bmRlZENvbnRhaW5lciIsImdyYXZpdHkiLCJkYW1waW5nIiwic3ByaW5nIiwiY29uc3RydWN0b3IiLCJzdGFydFNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/blob-simulation/blob.ts\n"));

/***/ })

});