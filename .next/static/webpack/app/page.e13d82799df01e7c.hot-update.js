"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Blob.ts":
/*!****************************!*\
  !*** ./components/Blob.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* binding */ Blob)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.core.js\");\n\nclass Blob {\n    update(blobs, springTension, canvasWidth, canvasHeight, margin, isRoundedContainer) {\n        console.log(\"Updating blob\", this);\n        // Apply velocity to position\n        this.position.add(this.velocity);\n        // Apply damping to velocity\n        this.velocity.multiplyScalar(0.98); // Example damping factor\n        // Keep the blob within canvas bounds\n        const radius = this.size;\n        if (this.position.x - radius < margin || this.position.x + radius > canvasWidth - margin) {\n            this.velocity.x *= -1; // Reverse velocity on X-axis\n            this.position.x = Math.max(margin + radius, Math.min(this.position.x, canvasWidth - margin - radius));\n        }\n        if (this.position.y - radius < margin || this.position.y + radius > canvasHeight - margin) {\n            this.velocity.y *= -1; // Reverse velocity on Y-axis\n            this.position.y = Math.max(margin + radius, Math.min(this.position.y, canvasHeight - margin - radius));\n        }\n        // Interact with other blobs (simple repulsion)\n        blobs.forEach((otherBlob)=>{\n            if (otherBlob === this) return;\n            const distance = this.position.distanceTo(otherBlob.position);\n            const minDistance = this.size + otherBlob.size;\n            if (distance < minDistance) {\n                const overlap = minDistance - distance;\n                const direction = this.position.clone().sub(otherBlob.position).normalize();\n                this.position.add(direction.multiplyScalar(overlap / 2));\n                otherBlob.position.sub(direction.multiplyScalar(overlap / 2));\n            }\n        });\n    }\n    draw(ctx, fillColor, borderColor) {\n        console.log(\"Drawing blob\", this);\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);\n        ctx.fillStyle = fillColor;\n        ctx.fill();\n        ctx.strokeStyle = borderColor;\n        ctx.stroke();\n        ctx.closePath();\n    }\n    getSVGPath() {\n        return \"M\".concat(this.position.x, \",\").concat(this.position.y, \" A\").concat(this.size, \",\").concat(this.size, \" 0 1,0 \").concat(this.position.x + 0.1, \",\").concat(this.position.y);\n    }\n    constructor(x, y, size, repelDistance){\n        this.position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\n        this.velocity = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);\n        this.size = size;\n        this.type = \"circle\";\n        this.repelDistance = repelDistance;\n        this.centre = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\n        this.targetArea = Math.PI * size * size;\n        this.maxRadius = size;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQW5CLElBQUksQ0FBQ2pDLFFBQVEsQ0FBQ00sQ0FBQyxFQUFDLEtBQXVCLE9BQXBCLElBQUksQ0FBQ04sUUFBUSxDQUFDVSxDQUFDLEVBQUMsTUFBaUIsT0FBYixJQUFJLENBQUNMLElBQUksRUFBQyxLQUFzQixPQUFuQixJQUFJLENBQUNBLElBQUksRUFBQyxXQUFrQyxPQUF6QixJQUFJLENBQUNMLFFBQVEsQ0FBQ00sQ0FBQyxHQUFHLEtBQUksS0FBbUIsT0FBaEIsSUFBSSxDQUFDTixRQUFRLENBQUNVLENBQUM7SUFDNUg7SUE1REF3QixZQUFZNUIsQ0FBUyxFQUFFSSxDQUFTLEVBQUVMLElBQVksRUFBRThCLGFBQXFCLENBQUU7UUFDckUsSUFBSSxDQUFDbkMsUUFBUSxHQUFHLElBQUlYLDBDQUFPQSxDQUFDaUIsR0FBR0k7UUFDL0IsSUFBSSxDQUFDUixRQUFRLEdBQUcsSUFBSWIsMENBQU9BLENBQUMsR0FBRztRQUMvQixJQUFJLENBQUNnQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDK0IsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUloRCwwQ0FBT0EsQ0FBQ2lCLEdBQUdJO1FBQzdCLElBQUksQ0FBQzRCLFVBQVUsR0FBRy9CLEtBQUtvQixFQUFFLEdBQUd0QixPQUFPQTtRQUNuQyxJQUFJLENBQUNrQyxTQUFTLEdBQUdsQztJQUNuQjtBQW9ERiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhbmllbC9EZXZlbG9wZXIvZW1hcm9ja3MvY29tcG9uZW50cy9CbG9iLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcblxuZXhwb3J0IGNsYXNzIEJsb2Ige1xuICBwb3NpdGlvbjogVmVjdG9yMjtcbiAgdmVsb2NpdHk6IFZlY3RvcjI7XG4gIHNpemU6IG51bWJlcjtcbiAgdHlwZTogc3RyaW5nO1xuICByZXBlbERpc3RhbmNlOiBudW1iZXI7XG4gIGNlbnRyZTogVmVjdG9yMjtcbiAgdGFyZ2V0QXJlYTogbnVtYmVyO1xuICBtYXhSYWRpdXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCByZXBlbERpc3RhbmNlOiBudW1iZXIpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IyKDAsIDApO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy50eXBlID0gXCJjaXJjbGVcIjtcbiAgICB0aGlzLnJlcGVsRGlzdGFuY2UgPSByZXBlbERpc3RhbmNlO1xuICAgIHRoaXMuY2VudHJlID0gbmV3IFZlY3RvcjIoeCwgeSk7XG4gICAgdGhpcy50YXJnZXRBcmVhID0gTWF0aC5QSSAqIHNpemUgKiBzaXplO1xuICAgIHRoaXMubWF4UmFkaXVzID0gc2l6ZTtcbiAgfVxuXG4gIHVwZGF0ZShibG9iczogQmxvYltdLCBzcHJpbmdUZW5zaW9uOiBudW1iZXIsIGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyLCBtYXJnaW46IG51bWJlciwgaXNSb3VuZGVkQ29udGFpbmVyOiBib29sZWFuKSB7XG4gICAgY29uc29sZS5sb2coXCJVcGRhdGluZyBibG9iXCIsIHRoaXMpO1xuXG4gICAgLy8gQXBwbHkgdmVsb2NpdHkgdG8gcG9zaXRpb25cbiAgICB0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLnZlbG9jaXR5KTtcblxuICAgIC8vIEFwcGx5IGRhbXBpbmcgdG8gdmVsb2NpdHlcbiAgICB0aGlzLnZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKDAuOTgpOyAvLyBFeGFtcGxlIGRhbXBpbmcgZmFjdG9yXG5cbiAgICAvLyBLZWVwIHRoZSBibG9iIHdpdGhpbiBjYW52YXMgYm91bmRzXG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5zaXplO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uLnggLSByYWRpdXMgPCBtYXJnaW4gfHwgdGhpcy5wb3NpdGlvbi54ICsgcmFkaXVzID4gY2FudmFzV2lkdGggLSBtYXJnaW4pIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueCAqPSAtMTsgLy8gUmV2ZXJzZSB2ZWxvY2l0eSBvbiBYLWF4aXNcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IE1hdGgubWF4KG1hcmdpbiArIHJhZGl1cywgTWF0aC5taW4odGhpcy5wb3NpdGlvbi54LCBjYW52YXNXaWR0aCAtIG1hcmdpbiAtIHJhZGl1cykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3NpdGlvbi55IC0gcmFkaXVzIDwgbWFyZ2luIHx8IHRoaXMucG9zaXRpb24ueSArIHJhZGl1cyA+IGNhbnZhc0hlaWdodCAtIG1hcmdpbikge1xuICAgICAgdGhpcy52ZWxvY2l0eS55ICo9IC0xOyAvLyBSZXZlcnNlIHZlbG9jaXR5IG9uIFktYXhpc1xuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gTWF0aC5tYXgobWFyZ2luICsgcmFkaXVzLCBNYXRoLm1pbih0aGlzLnBvc2l0aW9uLnksIGNhbnZhc0hlaWdodCAtIG1hcmdpbiAtIHJhZGl1cykpO1xuICAgIH1cblxuICAgIC8vIEludGVyYWN0IHdpdGggb3RoZXIgYmxvYnMgKHNpbXBsZSByZXB1bHNpb24pXG4gICAgYmxvYnMuZm9yRWFjaCgob3RoZXJCbG9iKSA9PiB7XG4gICAgICBpZiAob3RoZXJCbG9iID09PSB0aGlzKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5wb3NpdGlvbi5kaXN0YW5jZVRvKG90aGVyQmxvYi5wb3NpdGlvbik7XG4gICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IHRoaXMuc2l6ZSArIG90aGVyQmxvYi5zaXplO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBvdmVybGFwID0gbWluRGlzdGFuY2UgLSBkaXN0YW5jZTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLnN1YihvdGhlckJsb2IucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZChkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIob3ZlcmxhcCAvIDIpKTtcbiAgICAgICAgb3RoZXJCbG9iLnBvc2l0aW9uLnN1YihkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIob3ZlcmxhcCAvIDIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGZpbGxDb2xvcjogc3RyaW5nLCBib3JkZXJDb2xvcjogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coXCJEcmF3aW5nIGJsb2JcIiwgdGhpcyk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmModGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIHRoaXMuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgZ2V0U1ZHUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgTSR7dGhpcy5wb3NpdGlvbi54fSwke3RoaXMucG9zaXRpb24ueX0gQSR7dGhpcy5zaXplfSwke3RoaXMuc2l6ZX0gMCAxLDAgJHt0aGlzLnBvc2l0aW9uLnggKyAwLjF9LCR7dGhpcy5wb3NpdGlvbi55fWA7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMiIsIkJsb2IiLCJ1cGRhdGUiLCJibG9icyIsInNwcmluZ1RlbnNpb24iLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsIm1hcmdpbiIsImlzUm91bmRlZENvbnRhaW5lciIsImNvbnNvbGUiLCJsb2ciLCJwb3NpdGlvbiIsImFkZCIsInZlbG9jaXR5IiwibXVsdGlwbHlTY2FsYXIiLCJyYWRpdXMiLCJzaXplIiwieCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJ5IiwiZm9yRWFjaCIsIm90aGVyQmxvYiIsImRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsIm1pbkRpc3RhbmNlIiwib3ZlcmxhcCIsImRpcmVjdGlvbiIsImNsb25lIiwic3ViIiwibm9ybWFsaXplIiwiZHJhdyIsImN0eCIsImZpbGxDb2xvciIsImJvcmRlckNvbG9yIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJjbG9zZVBhdGgiLCJnZXRTVkdQYXRoIiwiY29uc3RydWN0b3IiLCJyZXBlbERpc3RhbmNlIiwidHlwZSIsImNlbnRyZSIsInRhcmdldEFyZWEiLCJtYXhSYWRpdXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Blob.ts\n"));

/***/ })

});